## FPGA Verilog RISC-V

### 《手把手教你设计CPU  RISC-V处理器》

1. E200处理器采用一套统一的VerilogRTL编码风格(Coding Style)，来自于严谨的工业级开发标准，其要点如下：
   + 使用标准DFF模块例化生成寄存器
   + 推荐使用Verilog中的assign语法替代if-else和case语法进行代码编写

2. 对于寄存器避免直接使用always块编写，而是应该采用模块化的标准DFF模块进行例化。示例如下所示，一个名为flg_dfflr的寄存器，除了时钟(clk)和复位信号(rst_n)之外，还带有使能信号flg_ena和输入(flg_nxt)/输出信号(flg_r).

3. 使用标准DFF模块例化的好处包括以下内容
   + 便于全局替换寄存器类型
   + 便于在寄存器中全面插入延迟
   + 明确的load-enable使能信号，方便综合工具自动插入寄存器级别的门控时钟以降低动态功耗
   + 便于规避Verilog语法if-else不能传播不定态的问题

4. 标准DFF模块内部则使用Verilog语法的always块进行编写，以dfflr为例，如下所示。由于Verilog if-else语法不能传播不定态，对处于if条件中的lden信号为不定态的非法情况使用断言(assertion)进行捕捉。

5. 推荐使用assign语法替代if-else和case语法。Verilog中的if-else和case语法存在两大缺点。

   + 不能传播不定态

   + 会产生优先级的选择电路而非并行选择电路，从而不利于时序和面积、

     详细解释如下：

     + 问题一，verilog的if-else不能传播不定态，以如下代码片段为例。假设a的值为X不定态，按照Verilog语法会将其等效为a==0,从而让out输出值等于in2最终没有将X不定态传播出去。这种情况可能会在仿真阶段掩盖某些致命的bug，造成芯片功能错误。而使用功能等效的assign语法，如下所示，假设a的值为X不定态，按照Verilog语法，则会将X不定态传播出去，从而让out输出值也等于X。通过X不定态的传播，可以在仿真阶段将bug彻底暴露出来

       ```verilog
       assign out = a ? in1 : in2 ;
       ```

       虽然现在有的EDA工具提供了专有选项(例如Synopsys VCS提供xprop选项)可以将Verilog原始语法中定义的“不传播不定态”的情形强行传播出来，但是一方面不是所有的EDA工具均支持此功能；另一方面在操作中此选项也时常被忽视。

     + 问题二，Verilog的Case语法也不能传播不定态，与问题一中的if-else同理。而使用等效的assign语法即可规避此缺陷

     + 问题三，Verilog的if-else语法会被综合成为优先级选择电路，面积和时序均不够优化，如下所示：

       ```verilog
       if(sell)
           out = in1[3:0];
       else if(sel2)
           out = in2[3:0];
       else if(sel3)
           out = in3[3:0];
       else 
           out = 4'b0;
       ```

       如果此处确实是希望生成一种优先级选择的逻辑，则推荐使用assign语法等效地编写成如下形式，以规避X不定态传播的问题：

       ```verilog
       assign out = sel1 ? in1[3:0] :
           sel2 ? in2[3:0] :
           sel3 ? in3[3:0] :
           4'b0;
       ```

       而如果此处本来是希望生成一种并行选择的逻辑，则推荐使用assign语法明确地使用“与” - “或”逻辑，编写如下：

       ```verilog
       assign out = ({4{sel1}} & in1[3:0])
           | ({4{sel2}} & in2[3:0])
           | ({4{sel3}} & in3[3:0]);
       //使用明确的assign语法编写的“与“ - ”或“ 逻辑一定能够保证综合生成并行选择的电路
       ```

       

     + 问题四，Verilog的Case语法也会被综合成为优先级选择电路，面积和时序均不够优化。有的EDA综合工具可以提供指引注释来使得综合工具能够综合出并行选择逻辑，但是这样可能会造成前后 仿真不一致的严重问题，从而产生重大的bug。因此，在实际工程开发中：
       + 应该命令禁止使用EDA综合工具提供的指引注释
       + 应该使用问题三推荐的等效assign语法编写电路

6. 编码风格的其他要点
   + 由于带有reset的寄存器面积和时序会稍微差一点，因此在数据通路上可以使用不带reset的寄存器，而只在控制通路上使用带reset的寄存器
   + 信号名定义应该避免使用拼音，注重使用英语缩写，信号名不可定义得过长，但是也不可以定义的过短。所谓代码即注释
   + Clock和Reset信号应禁止被用于任何其他的逻辑功能，Clock和Reset信号只能接入DFF作为其时钟和复位信号之用

7. 流水线：面积换性能，空间换时间。状态机：性能换面积，时间换空间。

   + 早期经典流水线是五级流水线，分别为取指、译码、执行、访问和写回。现代处理器具有极深的流水线，譬如高达十几级或者二十几级的深度。流水线被切得越细，每一级流水线内容纳的硬件逻辑越少。在两级寄存器之间的硬件逻辑越少，则意味着能够运行更高的主频。Cortex-A十几级流水线，x86几十级。
   + 每一级流水线都由寄存器组成，更多的流水线级数要消耗更多的寄存器以及更多的面积开销。这是流水线加深的负面意义
   + 由于每一级流水线需要进行握手，流水线最后一级的反压信号可能会一直串扰到最前一级造成严重的时序问题，需要使用一些比较高级的技巧来解决此类问题。这是流水线加深的负面意义。
   + 较深的处理器流水线还有一个问题，那就是由于在流水线的取指令阶段无法得知条件跳转的结果是到底跳还是不跳，因此只能进行预测.而到了流水线的末端才能够通过实际的运算得知该分支是真的该跳还是不该跳。如果发现真实的结果与之前预测的结果不相符，则意味着预测失败，需要将所有预取的错误指令流全部丢弃掉。重新取正确的指令流，这个过程叫做“流水线冲刷(Pipeline Flush)”。虽然可以使用分支预测器来保证前期的分支预测尽可能准确，但是也无法做到万无一失。流水线越深，浪费和损失越严重。这是流水线加深的另一个主要的负面意义。
   + Cortex-A7主打低功耗前提下的能效比，其流水线级数为8级；而Cortex-A15主打高性能，其流水线深度为15级；Cortex-M3/M0流水线为三级；Cortex-M0+流水线为二级。

8. 流水线中的反压：流水线越深，由于每一级流水线需要进行握手，流水线最后一级的反压信号可能会一直串扰到最前一级造成严重的反压(Back-pressure)时序问题，需要使用一些比较高级的技巧来解决这些时序问题。在现代处理器设计中，通常有如下3中方法：
   + 取消握手：此方法能够杜绝反压的发生，时序表现非常好。但是取消握手，即意味着流水线中的每一级并不会与其下一级进行握手，可能会造成更能错误或者指令丢失。因此这种方法往往需要配合其他的机制，譬如重执行(Replay)、预留大缓存等。简而言之，此方法比较激进，辅以一系列其他的配置机制，硬件总体的复杂度会比较大，只有在一些非常高级的处理器设计中才会用到。
   + 加入乒乓缓存：加入乒乓缓存(Ping-pong Buffer)是一种用面积换时序的方法，也是在解决反压的最简单的方法。通过使用乒乓缓存(有两个表项)替换掉普通的一级流水线(只有一个表项)，可以使得此级流水线向上一级流水线的握手接收信号仅关注乒乓缓存中是否有一个以上有空的表项即可，而无需将下一级的握手接收信号串扰至上一级。
   + 加入前向旁路缓存：加入前向旁路缓存(Forward Bypass Buffer)也是一种用面积换时序的方法，是在解决反压时的一种非常巧妙的方法。旁路缓存仅只有一个表项，由于增加了这一个额外的缓存表项，可以将后向的握手信号时序路劲砍断，但是对前向路径不受影响，因此可以广泛使用于握手接口。

9. 处理器流水线的冲突：处理器的流水线设计中的另一个问题是流水线中的冲突(Hazards)，主要分为资源冲突和数据冲突。数据冲突是指不同的指令之间的操作数存在着数据相关性造成的冲突，常见的数据相关性如下：

   + WAR(Write-After-Read)相关性，又称先读后写相关性：表示“后序执行的指令需要写回的结果寄存器索引”与“前序执行的指令需要读取的源操作数寄存器索引”相同造成的数据相关性。因此从理论上来讲，在流水线中“后续指令”一定不能比和它有WAR相关性的“前序指令”先执行，否则“后序指令”先写回了结果至通用寄存器组中，“前序指令”再读取操作数时，就会读到错误的数值。

   + WAW(Write-After-Write)相关性，又称先写后写相关性：表示“后序执行的指令需要写回的结果寄存器索引”与“前序执行的指令需要写回的结果寄存器索引”相同造成的数据相关性。因此从理论上来讲，在流水线中“后序指令”一定不能比和它有WAW相关性的“前序指令”先执行，否则“后序指令”先写回了结果至通用寄存器组中，“前序指令”再写回结果通用寄存器组中就会将其覆盖。

   + RAW(Read-After-Write)相关性，又称先写后读相关性：表示“后序执行的指令需要读取的源操作数寄存器索引”与“前序执行的 指令需要写回的结果寄存器索引”相同造成的数据相关性。因此从理论上来讲，在流水线中“后序指令”一定不能比和它有RAW相关性的“前序指令”先执行，否则“后序指令”便会从通用寄存器组中读回错误的源操作数。

     以上的3种相关性中，RAW属于真数据相关。解决数据冲突的常见方法如下

     1. WAW和WAR可以通过寄存器重命名的方法将相关性去除，从而无需担心其执行顺序。寄存器重命名技术在Tomasulo算法中通过保留站和ROB(Re-Order Buffer)完成，或者采用纯物理寄存器(而不用ROB)的方式完成。
     2. RAW没有办法通过寄存器重命名的方法将相关性去除。一旦产生RAW相关性，后序的指令一定要使用和它有RAW数据相关性的前序指令执行完成的结果，从而造成流水线的等待停顿。可以使用“动态调度”的方法。动态调度的思想本质上可以归结于以下方面。
        + 一方面采用数据旁路传播(Data Bypass and Forward)技术，尽可能让前序指令的计算结果更快地旁路给后序相关指令的操作数。
        + 另一方面尽可能地让后序相关指令在等待的过程中不阻塞流水线，而让其他无关的指令继续顺利执行。
        + 早期的Tomasulo算法中通过保留站可以达到这两方面的功效，但是保留站由于保存了操作数，无法做到很大的深度
        + 最新的高性能处理器普遍采用在每个运算单元前配置乱序发射队列(Issue Queue)的方式，发射队列仅追踪RAW相关性，并不存放操作数，因此可以做到很深。在发射队列中的指令一旦相关性解除之后，再从发射队列中发射出来读取物理寄存器组，然后发送给运算单元开始计算。