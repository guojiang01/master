## ARM汇编指令

```assembly
<opcosd> {<cond> {s} <Rd>,<Rn> {,<operand2>}}
```

这是一个完整的ARM指令需要遵循的格式规则。指令格式的具体说明如下。

+ 使用<>标起来的是必选项，使用{}标起来的是可选项
+ <opcode>是二进制机器指令的操作码助记符，如MOV、ADD这些汇编指令都是操作码的指令助记符
+ cond：执行条件，ARM为减少分支跳转指令个数，允许类似BEQ、BNE等形式的组合指令
+ S：是否影响CPSR寄存器中的标志位，如SUBS指令会影响CPSR寄存器中的N、Z、C、V标志位，而SUB指令不会
+ Rd：目标寄存器
+ Rn：第一个操作数的寄存器
+ operand2：第二个可选操作数，灵活使用第二个操作数可以提高代码效率

```assembly
LDR R1,[R0] ;将R0中的值作为地址，将该地址上的数据保存到R1
STR R1,[R0] ;将R0中的值作为地址，将R1中的值存储到这个内存地址
LDRB/STRB ;每次读写一字节，LDR/STR默认每次读写4字节
LDM/STM ;批量加载/存储指令，在一组寄存器和一片内存之间传输数据
SWP R1,R1,[R0] ;将R1和R0中地址指向的内存单元中的数据进行交换
SWP R1,R2,[R0] ;将[R0]存储到R1，将R2写入[R0]这个内存单元
LDMFD SP!,{R0-R2,R14} ;将内存栈中的数据依次弹入到R14,R2,R1,R0
STMFD SP!,{R0-R2,R14} ;将R0,R1,R2,R14依次压入内存栈
PUSH {R0-R2,R14} ;将R0,R1,R2,R14依次压入栈
POP  {R0-R2,R14} ;将栈中的数据依次弹出到R14,R2,R1,R0
;LDR/STR指令用来在寄存器和内存之间输送数据
MOV R1,#1 ;将立即数1传送到寄存器R1中
MOV R1,R0 ;将R0寄存器中的值传送到R1寄存器中
MOV PS,LR ;子程序返回
MVN R0,#0xFF ;将立即数0XFF取反后赋值给R0
MVN R0,R1 ;将R1寄存器的值取反后赋值给R0
ADD R2,R1,#1 ;R2=R1+1
ADC R1,R1,#1 ;R1=R1+1+C(其中C为CPSR寄存器中进位)
SUB R1,R1,R2 ;R1=R1-R2;
SBC R1,R1,R2 ;R1=R1-R2-C;
AND R0,R0,#3 ;保留R0的bit0和1，其余位清除
ORR R0,R0,#3 ;置位R0的bit0和bit1
EOR R0,R0,#3 ;反转R0中的bit0和bit1
BIC R0,R0,#3 ;清除R0中的bit0和bit1
#constant,n ;将立即数constant循环右移n位
ASR #n ;算数右移n位，n的取值范围：[1，32]
LSL #n ;逻辑左移n位，n的取值范围：[0,31]
LSR #n ;逻辑右移n位，n的取值范围；[1,32]
ROR #n ;向右循环移n位，n的取值范围：[1，31]
RRX ;向右循环移1位，带扩展
type Rs ;仅在ARM中可用，其中type指ASP LSL LSR ROR ,Rs是提供位移量的寄存器名称
ADD R3,R2,R1,LSL #3 ;R3=R2+R1<<3
ADD R3,R2,R1,LSL R0 ;R3=R2+R1<<R0
ADD IP,IP,#16,20 ;IP=IP+立即数16循环右移20位
CMP R1,#10 ;R1-10,运算结果会影响N Z C V 位
CMP R1,R2  ;R1-R2,比较结果会影响N Z C V 位
CMN R0,#1  ;R0-(-1)将立即数取负，然后比较大小
B {cond} label ;跳转到标号label执行
B {cond} Rm ;寄存器Rm中保存的是跳转地址
B label ；跳转到标号label处
BL label；带链接的跳转
BX Rm ;带状态切换的跳转
```

## ARM 指令的条件码

| 条件  | CPSR标志位 | 说明               | 条件码 | CPSR标志位   | 说明               |
| ----- | ---------- | ------------------ | ------ | ------------ | ------------------ |
| EQ    | Z=1        | 相等               | HI     | C置位，Z清零 | 无符号数大于       |
| NE    | Z=0        | 不相等             | LS     | C清零，Z置位 | 有符号数小于或等于 |
| CS/HS | C=1        | 无符号数大于或等于 | GE     | N=V          | 有符号数大于或等于 |
| CC/LO | C=0        | 无符号数小于       | LT     | N!=V         | 有符号数小于       |
| MI    | N置位      | 负数               | GT     | Z清零，N=V   | 有符号数大于       |
| PL    | N清零      | 正数或零           | LE     | Z置位，N!=V  | 有符号数小于或等于 |
| VS    | V置位      | 溢出               | AL     | 忽略         | 无条件执行         |
| VC    | V清零      | 未溢出             | NV     | 忽略         | 从不执行           |

## ARM 伪指令

```assembly
ADD R0,LOOP ;将标号LOOP的地址保存到R0寄存器中
ADRL R0,LOOP ;中等范围的地址读取
LDR R0, =0x30008000 ;将内存地址0x3000800赋值给R0
NOP;空操作，用于延时或插入流水线中暂停指令的运行
```

## C语言和汇编语言混合编程

1. ATPCS(ARM-Thumb Procedure Call Standard)规则

   + 子程序见要通过寄存器R0~R3传递参数，当参数个数大于4时，剩余的参数使用堆栈来传递

   + 子程序通过R0~R1返回结果

   + 子程序中使用R4~R11(可记作V1-V8)来保存局部变量

   + R12作为调用过程中的临时寄存器，一般用来保存函数的栈帧基址，记作FP

   + R13作为堆栈指针寄存器，一般记作SP

   + R14作为链接寄存器，用来保存函数调用者的返回地址，记作LR

   + R15作为程序计数器，总是指向当前正在运行的指令，记作PC

     