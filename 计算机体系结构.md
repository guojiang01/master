# 计算机体系结构

### 计算机组成与设计：硬件/软件接口 （MIPS版）

*2015年7月第1版第1次印刷* 

1. 计算机体系结构中的8个伟大思想
   1. 面向摩尔定律的设计：18~24个月集成度翻一番
   2. 使用抽象简化设计
   3. 加速大概率事件
   4. 通过并行提高性能
   5. 通过流水行提高性能
   6. 通过预测提高性能
   7. 存储器层次
   8. 通过冗余提高可靠性

2. 操作系统最为重要的是：
   + 处理基本的输入和输出操作
   + 分配外存和内存
   + 为多个应用程序提供 共享计算机资源的服务

3. 指令集：一个给定的计算机体系结构所包含的指令集合。
4. **MIPS操作数** 

| 名字               | 示例                                                         | 注释                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 32个寄存器         | \$s0-\$7,\$t0-\$t9,\$zero,<br />\$a0-\$a3,\$v0-\$v1,\$gp,<br />\$fp,\$sp,\$ra,\$at | 寄存器用于数据的快速存取。在MIPS中，只能对存放在寄存器中的数据执行算数操作，寄存器\$zero的值恒为0，寄存器\$at被汇编器保留，用于处理非常大的数据 |
| $2^{30}$个存储器字 | Memory[0],Memory[4],...<br />Memory[4294967292]              | 存储器只能通过数据传输指令访问。MIPS使用字节编址，所以连续的字地址相差4.存储器用于保存数据结构、数组和溢出的寄存器。 |

5. **MIPS汇编语言** 

| 指令                               | 示例  |
| ---------------------------------- | ----- |
| 加法                               | add   |
| 减法                               | sub   |
| 立即数加法                         | addi  |
| 取字                               | lw    |
| 存字                               | sw    |
| 取半字                             | lh    |
| 取无符号半字                       | lhu   |
| 存半字                             | sh    |
| 取字节                             | lb    |
| 取无符号字节                       | lbu   |
| 存字节                             | sb    |
| 取链接字                           | ll    |
| 存条件字                           | sc    |
| 取立即数的高位                     | lui   |
| 与                                 | and   |
| 或                                 | or    |
| 或非                               | nor   |
| 立即数与                           | andi  |
| 立即数或                           | ori   |
| 逻辑左移                           | sll   |
| 逻辑右移                           | srl   |
| 相等时跳转                         | beq   |
| 不相等时跳转                       | bne   |
| 小于时置位                         | slt   |
| 无符号数比较小于时置位             | sltu  |
| 无符号数比较立即数时置位           | slti  |
| 无符号数比较小于无符号立即数时置位 | sltiu |
| 跳转                               | j     |
| 跳转至寄存器所指位置               | jr    |
| 跳转并链接                         | jal   |

6. 硬件设计的三条规则：
   + 简单源于规整
   + 越小越快
   + 优秀的设计需要适宜的折中方案

7. MIPS字段

   R型(用于寄存器)

| op              | rs                             | rt                             | rd                                      | shant      | funct      |
| --------------- | ------------------------------ | ------------------------------ | --------------------------------------- | ---------- | ---------- |
| 6位<br />操作码 | 5位 第一个源操<br />作数寄存器 | 5位 第二个源操<br />作数寄存器 | 5位：用于存放操作<br />结果的目的寄存器 | 5位 位移量 | 6位 功能码 |

​	I型(用于立即数)

| op   | rs   | rt   | constant or address |
| ---- | ---- | ---- | ------------------- |
| 6位  | 5位  | 5位  | 16位                |

8. 并行与指令：同步。任务之间需要同步，否则就有发生数据竞争的危险，导致读数据错误而引起程序运行结果的改变。加锁(lock)和解锁(unlock)同步操作的实现。采用加锁和解锁可以直接创立一个仅允许单个处理器操作的区域，叫做互斥(mutual exclusion)区。更复杂的同步机制实现也与此类似。在多处理器中实现同步需要一组硬件原语，提供对存储单元进行原子读和原子写的能力，使得在进行存储器原子读或原子写操作时任何其他操作都不得插入。

9. 指令级并行：流水线挖掘了潜在的并行性。这种并行性被称为指令级并行。有两种方法可以增加潜在的指令级并行程度。第一种是增加流水线的深度以重叠更多的指令。另一种方法是复制计算机内部部件的数量，使得每个流水级可以启动多条指令，这种技术一般被称为多发射。**指令级并行：指令间的并行性；多发射：一种单时钟周期内发射多条指令的机制** 
   + 实现一个多发射处理器主要有两种方式，其区别是将主要工作分给编译器来做还是硬件来做。由于不同的实现方式将导致某些决策是静态进行的(在编译时)还是动态进行的(在执行时)，所以这两种方式有时也被称为**静态多发射**和**动态多发射**。
   + 多发射流水线必须处理以下问题：
     1. 往发射槽中发射多条指令：处理器如何确定在给定的时钟周期发射多少条指令以及发射何种指令呢？在大多数静态发射处理器中，这个过程至少有很大一部分是由编译器处理的。而在动态发射处理器中，这个问题一般是由处理器在运行时处理的，尽管编译器也会尽其所能通过调整顺序加以协助。
     2. 处理数据冒险和控制冒险：在静态发射处理器中，部分甚至全部的数据冒险和控制冒险是由编译器静态处理的。相反，绝大多数的动态发射处理器通过硬件技术在执行时至少消除某些类别的冒险。
     3. 发射槽：在给定时钟周期内能够发射指令的位置，可以类比与短跑比赛中的起点位置。
     4. 推测：一种编译器或处理器推测指令结果以消除执行其他指令对该结果依赖的方法。
     5. 发射包：在一个时钟周期内发射的多条指令的集合。这个包可以由编译器静态生成，也可以有处理器动态生成
     6. 超长指令字：一类可以同时启动多个操作的指令集，其中操作在单个指令中相互独立，并且一般都由独立的操作码字段。
     7. 动态多发射处理器通常也称为超标量处理器或简称**超标量**。
     8. 超标量：一种高级流水线技术，可以使每个周期处理器能执行的指令数超过一条。
     9. 动态流水线调度：对指令进行重排序以避免阻塞的硬件支持。
     10. 提交单元：位于动态流水线和乱序流水线中的一个单元，用以决定何时可以安全地将操作结果送至程序员可见的寄存器和存储器
     11. 保留站：功能单元的缓冲区，用来保存操作数和操作
     12. 重排序缓冲区：动态调度处理器中用于暂时保存执行结果的缓冲区，等到安全时才将其中的结果写回寄存器或存储器。
     13. 乱序执行：流水线执行的一种情况，即执行的指令被阻塞时不会导致后面的指令等待
     14. 顺序提交：流水线执行的结果以取指顺序写回程序员可见存储器的一种提交方式。

10. Cortex-A8处理器主频1GHz，具有14级流水线。动态多发射技术，每个时钟周期可以发射两条指令，其流水线位静态顺序流水线，指令发射、执行和提交顺序执行。

11. 存储器层次结构

    1. 时间局部性：某个数据项在被访问之后可能很快再次被访问的特性

    2. 空间局部性：某个数据项在被访问之后，与其地址相近的数据项可能很快被访问的特性

    3. 块或行：可存在于或不存在与cache中的信息的最小单元。命中率：在高层存储器中找到目标数据的存储访问比例。缺失率：在高层存储器中没有找到目标数据的存储访问比例。命中时间：访问某存储器层次结构所需要的时间，包括了判断当前访问是命中还是缺失所需的时间。缺失代价：将相应的块从低层存储器替换到高层存储器所需的时间，包括访问块、将数据逐层传输、将数据插入发生缺失的层和将信息块传送给请求者的时间。

    4. | 存储器技术 | 典型访问时间(ns) |
       | ---------- | ---------------- |
       | SRAM       | 0.5~2.5          |
       | DRAM       | 50~70            |
       | Flash      | 5000~50000       |
       | 磁盘       | 5000000~20000000 |

       

---

### 计算机组成与设计：硬件/软件接口 （ARM版） 

*2018年10月第1版第1次印刷* 

第一章和附录与MIPS版相同。

1. LEGv8操作数

| 名称             | 示例                                                       | 注释                                                         |
| ---------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 32个寄存器       | X0~X30，XZR                                                | 寄存器用于数据的快速存取。在LEGv8中，数据只能存放在寄存器中以参与算术运算，寄存器XZR恒为0 |
| $2^{62}$个寄存器 | Memory[0],Memory[4]...Memory<br />[4611686018018427387904] | 寄存器只能通过数据传输指令访问。LEGv8采用字节编址，所以连续的双字节地址相差8.寄存器存储数据结构、数组和溢出的寄存器。 |

2. LEGv8汇编语言

| 指令   | 含义                         |
| ------ | ---------------------------- |
| ADD    | 寄存器加                     |
| SUB    | 寄存器减                     |
| ADDI   | 加常数                       |
| SUBI   | 减常数                       |
| ADDS   | 加法，设置条件码             |
| SUBS   | 减法，设置条件码             |
| ADDIS  | 加常数，设置条件码           |
| SUSIS  | 减常数，设置条件码           |
| LDUR   | 将双字从存储器取到寄存器     |
| STUR   | 将双字从寄存器存入寄存器     |
| LDURSW | 将一个字从存储器取到寄存器   |
| STURW  | 将一个字从寄存器存入存储器   |
| LDURH  | 将半字从存储器取到寄存器     |
| STURH  | 将半字从寄存器存入存储器     |
| LDURB  | 将一个字节从存储器取到寄存器 |
| STURB  | 将一个字节从寄存器存入存储器 |
| LDXR   | 取数，原子交换的第一部分     |
| STXR   | 存数，原子交换的第二部分     |
| MOVZ   | 取16位常数，其余位置0        |
| MOVK   | 取16位常数，其余位不变       |
| AND    | 按位与                       |
| ORR    | 按位或                       |
| EOR    | 按位异或                     |
| ANDI   | 寄存器数和常数按位与         |
| ORRI   | 寄存器数和常数按位或         |
| EORI   | 寄存器数和常数按位异或       |
| LSL    | 向左移动常数位               |
| LSR    | 向右移动常数位               |
| CBZ    | 比较是否等于0；PC相对跳转    |
| CBNZ   | 比较是否不等于0；PC相对跳转  |
| B.cond | 条件码检测；结果为真则跳转   |
| B      | 跳转到目标地址；PC相对       |
| BR     | 用于switch语句，过程返回     |
| BL     | 用于PC相对的过程调用         |

3. ARMv8和Intel x86没有对齐限制，而ARMv7和MIPS有对齐限制。ARMv8支持对普通存储器的非对齐访问，但栈访问和取指令必须遵守对齐限制。
4. LEGv8寄存器

| 名称     | 寄存器号 | 用途                                                 | 调用时是否保存 |
| -------- | -------- | ---------------------------------------------------- | -------------- |
| X0~X7    | 0~7      | 参数/结果                                            | 否             |
| X8       | 8        | 间接结果位置寄存器                                   | 否             |
| X9~X15   | 9~15     | 临时变量                                             | 否             |
| X16(IP0) | 16       | 被链接器作为暂存寄存器使用，或作为临时寄存器         | 否             |
| X17(IP1) | 17       | 被链接器作为暂存寄存器使用，或作为临时寄存器         | 否             |
| X18      | 18       | 在平台无关的代码中用作平台寄存器，否则作为临时寄存器 | 否             |
| X19~X27  | 19~27    | 保存                                                 | 是             |
| X28(SP)  | 28       | 栈指针                                               | 是             |
| X29(FP)  | 29       | 帧指针                                               | 是             |
| X30(LR)  | 30       | 链接寄存器(返回地址)                                 | 是             |
| XZR      | 31       | 常数0                                                | 不适用         |

5. 寻址模式：
   + 立即数寻址，操作数是位于指令自身中的常数
   + 寄存器寻址，操作数是寄存器
   + 基址寻址或偏移寻址，操作数在内存中，其地址是一个寄存器和指令中常数的和
   + PC相对寻址，地址是PC与指令中常数的和

6.  编译器->汇编器->链接器->加载器

   + 编译器将C程序转换成机器能理解的符号形式的汇编语言程序。
   + 汇编器将分支和数据传输指令中用到的标号都放入一个符号表中.UNIX系统中的目标文件通常包含以下六个不同的部分：
     + 目标头文件，描述目标文件其他部分的大小和位置
     + 代码段，包含机器语言代码
     + 静态数据段，包含在程序生命周期内分配发数据
     + 重定位信息，标记了一些在程序加载进内存时依赖于绝对地址的指令和数据
     + 符号表，包含剩余未定义的标签，如外部引用
     + 调试信息，包含一份简明描述，说明模块如何编译，以便调试器能够将机器指令关联到C源文件，并使数据结构也变得可读。

   + 链接器的工作分为三个步骤：
     + 将代码和数据模块象征性地放入内存
     + 决定数据和指令标签的地址
     + 修补内部和外部引用

   + 加载器：
     + 读取可执行文件头来确定代码段和数据段的大小
     + 为代码和数据创建一个足够大的地址空间
     + 将可执行文件中的指令和数据复制到内存中
     + 把主程序的参数(如果有)复制到栈中
     + 初始化处理器中的相关寄存器，将栈指针指向第一个空位置
     + 跳转到启动例程，该例程将参数复制到参数寄存器并且调用程序的main函数。当main函数返回时，启动例程通过系统调用exit终止程序。

***

## 计算机组成与设计：硬件/软件接口 （RISC-V版） 

*2020年5月第1版第1次印刷*

1.RISC-V操作数

| 名字             | 示例                                                     | 注解                                                         |
| ---------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 32个寄存器       | X0~X31                                                   | 快速定位数据，在RISC-V中，只对在寄存器中的数据执行算术运算   |
| $2^{61}$个存储字 | Memory[0],Memory[4]...Memory<br />[18446744073709551608] | 只能被数据传输指令访问，RISC-V使用字节寻址，因此顺序双字访问相差8.存储器保存数据结构、数组和换出的寄存器内容 |

2. RISC-V汇编语言

| 指令 | 注解                                               |
| ---- | -------------------------------------------------- |
| add  | 加                                                 |
| sub  | 减                                                 |
| addi | 加常数                                             |
| ld   | 从存储器取双字到寄存器                             |
| sd   | 从寄存器存双字到存储器                             |
| lw   | 从存储器取字到寄存器                               |
| lwu  | 从存储器取无符号字到寄存器                         |
| sw   | 从寄存器存字到存储器                               |
| lh   | 从存储器取半字到寄存器                             |
| lhu  | 从存储器取无符号半字到寄存器                       |
| sh   | 从寄存器存半字到存储器                             |
| lb   | 从存储器取字节到寄存器                             |
| lbu  | 才存储器取无符号字节到寄存器                       |
| sb   | 从寄存器存字节到存储器                             |
| lr.d | 取；原子交换的前半部分                             |
| sc.d | 存；原子交换的后半部分                             |
| lui  | 取左移12位后的20位立即数                           |
| and  | 按位与                                             |
| or   | 按位或                                             |
| xor  | 按位异或                                           |
| andi | 寄存器与常数按位与                                 |
| ori  | 寄存器与常数按位或                                 |
| xori | 寄存器与常数按位异或                               |
| sll  | 按寄存器给定位数左移                               |
| srl  | 按寄存器给定位数右移                               |
| sra  | 按寄存器给定数位算术右移                           |
| slli | 根据立即数给定位数左移                             |
| srli | 根据立即数给定位数右移                             |
| srai | 根据立即数给定位数算术右移                         |
| beq  | 若寄存器数值相等测跳转到PC相对地址                 |
| bne  | 若寄存器数值不等测跳转到PC相对地址                 |
| blt  | 若寄存器数值比较结果小于则跳转到PC相对地址         |
| bge  | 若寄存器数值比较结果大于则跳转到PC相对地址         |
| bltu | 若寄存器数值比较结果小于则跳转到PC相对地址(无符号) |
| bgeu | 若寄存器数值比较结果大于则跳转到PC相对地址(无符号) |
| jal  | 用于PC相关的过程调用                               |
| jalr | 用于过程返回；非直接调用                           |

3. RISC-V寄存器约定

| 名称    | 寄存器号 | 用途                 | 调用时是否保存 |
| ------- | -------- | -------------------- | -------------- |
| X0      | 0        | 常数0                | 不适用         |
| X1(ra)  | 1        | 返回赋值(链接寄存器) | 是             |
| X2      | 2        | 栈指针               | 是             |
| X3      | 3        | 全局指针             | 是             |
| X4      | 4        | 线程指针             | 是             |
| X5~X7   | 5~7      | 临时                 | 否             |
| X8~X9   | 8~9      | 保存                 | 是             |
| X10~X17 | 10~17    | 参数/结果            | 否             |
| X18~X27 | 18~27    | 保存                 | 是             |
| X28~X31 | 28~31    | 临时                 | 否             |

---

## 计算机体系结构：量化研究方法

1.DDR DRAM和DIMM的时钟频率、带宽和名称

| 标准 | 时钟频率(MHz) | 每秒传输个数(百万个) | DRAM名称  | MB/s/DIMM   | DIMM名称 |
| ---- | ------------- | -------------------- | --------- | ----------- | -------- |
| DDR  | 133           | 266                  | DDR266    | 2128        | PC2100   |
| DDR  | 150           | 300                  | DDR300    | 2400        | PC2400   |
| DDR  | 200           | 400                  | DDR400    | 3200        | PC3200   |
| DDR2 | 266           | 533                  | DDR2-533  | 4264        | PC4300   |
| DDR2 | 333           | 667                  | DDR2-667  | 5336        | PC5300   |
| DDR2 | 400           | 800                  | DDR2-800  | 6400        | PC6400   |
| DDR3 | 533           | 1066                 | DDR3-1066 | 8528        | PC8500   |
| DDR3 | 666           | 1333                 | DDR3-1333 | 10664       | PC10700  |
| DDR3 | 800           | 1600                 | DDR3-1600 | 12800       | PC12800  |
| DDR4 | 1066-1600     | 2133-3200            | DDR4-3200 | 17056-25600 | PC25600  |

第三列是第二列的2倍，第四列DRAM芯片名称中使用了第三列中的数字。第五列是第三列的8倍，DIMM名称中使用了这一数字的四舍五入值。根据DDR标准，DDR还以4个数字指明了时钟周期中的延迟。例如，DDR3-2000 CL9的延迟为9-9-9-28。意思是对于一个周期为1ns的时钟(时钟周期是传输速度的一半)，这一数字意味着行至列地址为9ns(RAS时间)，列地址到数据为9ns(CAS时间)，最短读取时间为28ns。关闭该行将需要9ns进行预充电，但只有在完成改行的读取时才会进行这一操作。在突发模式中，经过第一RAS时间与CAS时间后，在每个时钟的上下沿都会进行传输。DDR-2.5V,DDR2-1.8V,DDR3-1.5V,DDR4-1.2V.

2. 大约1985年之后的所有处理器都使用流水线来重叠指令的执行过程，以提高性能。由于指令可以并行执行，所以指令之间的可能实现的这种重叠称为指令级并行(ILP).
