# 数字电路设计及FPGA

### 一门最好的语言就是在你的环境里已经使用的语言或者是客户要求使用的语言 

1. 同步时序电路：包含环路的环，它的输出直接反馈到输入，它们是时许电路而不是组合电路。组合逻辑没有环路和竞争。为了避免这些问题，设计师在路径中插入寄存器来断开环路。将电路转变成组合逻辑和寄存器的集合。寄存器包含系统的状态，这些状态仅仅在时钟到达时发生改变，所有说状态**同步于**时钟信号。如果时钟足够慢，使得在下一个时钟沿到达之前输入到寄存器的信号都可以稳定下来，那么所有的竞争都将被消除。

2. **同步时序电路**有一个时钟输入，它的上升沿表示时序电路状态转变发生的事件。我们经常使用术语*当前状态*和*下一个状态*来区分目前系统的状态和下一个时钟沿系统将要进入的状态。

3. 时序规范包括上界时间$t_{pcq}$和下界时间$t_{ccq}$ ，它是从时钟的上升沿知道**输出**改变的时间以及**建立**时间$t_{setup}$和**保持**时间$t_{hold}$,它表示当前**输入**必须相对于时钟的上升沿稳定。

4. **同步时序电路的组成**规则告诉我们，一个电路是同步时序电路，如果它由相互连接的电路元件构成，且需要满足一下条件。
   + 每一个电路元件是寄存器或者是组合电路
   + 至少有一个元件是寄存器
   + 所有寄存器都接收同一个时钟信号
   + 每个环路至少包含一个寄存器

5. 两种常见的同步时序电路成为**有限状态机**和**流水线**

6. 由电路图导出状态机
   + 检查电路，标明输入、输出和状态位
   + 写出下一个状态和输出表
   + 创建下一个状态和输出表
   + 删除不可达状态来简化下一个状态表
   + 给每个有效状态位组合指定状态名称
   + 用状态名称重写下一个状态和输出表
   + 画出状态转换图
   + 使用文字阐述有限状态机的功能

7. 有限状态机小结

   + 确定输入和输出
   + 画出状态转换图
   + 对于$Moore$型状态机：
     + 写出状态转换表
     + 写出输出表

   + 对于$Mealy$型状态机：
     + 写出组合的状态转换表和输出表

   + 选择状态编码——这个选择将影响硬件设计
   + 为下一个状态和输出逻辑写出布尔表达式
   + 画出电路草图

8. **动态约束**

   为了电路对输入正确采样，在时钟上升沿到来前，输入必须在*建立时间*(setup time) $t_{setup}$内保持稳定，在时钟上升沿后，输入必须保持至少*保持时间*（hold time）$t_{hold}$内保持稳定。建立时间和保持时间统称为电路的*孔径时间*，因为它是输入保持稳定状态的时间总和。

   **动态约束**是指同步时序电路的输入必须在时钟沿附近的建立和维持孔径时间内保持稳定

9. **建立时间约束** 

   $t_{pd}\leq T_c-(t_{pcp}+t_{setup})$ 制造商确定触发器时钟到$Q$的传播延迟$t_{pcq}$和建立时间$t_{setup}$.在圆括号内的项$t_{pd}+t_{setup}$称为*时序开销*。理想状态下，整个周期时间$T_c$都应用于组合逻辑中有用的计算，其传播延迟为$t_{pd}$。但是，触发器的时序开销占用了周期时间。上式称为*建立时间约束*或*最大延迟约束*，因为它取决于建立时间，并限制通过组合逻辑的最大延迟。
   
   + 解决问题的方法有两个：增加时钟周期或重新设计组合逻辑来缩短传播延迟

10. **保持时间约束**

    $t_{cd}\geq t_{hold}-t_{ccq}$ 称为*保持时间约束*或者*最小延迟约束*，因为它限制了通过组合逻辑的最小延迟。如果不能满足，则唯一的解决方法是重新设计电路以便增加组合逻辑的最小延迟。与建立约束不同，他们不能通过调整时钟周期来改正。

11. 数字系统设计人员的目标是：对于给定的异步输入，确保遇到的亚稳态电压的概率足够小。为了确保产生正确的逻辑电平，所有的异步输入必须经过*同步器* 。

    + 用2个触发器来建立同步器的简单方法。$F1$在$CLK$的上升沿对$D$进行采样，如果$D$在这个时刻发生改变，则输出$D2$将出现暂时的亚稳态。如果时钟周期足够长，则在周期结束前$D2$成为一个有效逻辑电平的概率很高。然后$F2$对$D2$进行采样，它现在是稳定的，将产生一个好的输出$Q$ ($F1$$F2$为$D$触发器)

    + 如果同步器的输出$Q$为亚稳态，那么这个同步器将*失效*。

    + 系统的可靠性通常由**平均失效间隔时间（MTBF）**度量。根据定义可以看出,**MTBF**是系统失效之间的平均时间。它是系统失效概率的倒数：

      **MTBF**=$\frac1{P(失效)/sec}$=$\frac{T_ce^{T_c-t_{setup}}}{NT_0}$ 

12. 系统的速度可以用延迟和通过系统的信息吞吐量来度量。**任务**定义为经过处理后能产生一组输出的一组输入。**延迟**是从开始到结束所需的时间。**吞吐量**是系统单位时间内产生的任务的数量

13. 与输出只取决于当前输入的组合逻辑电路相比，时许逻辑电路的输出取决于当前和先前的输入。换句话说，时许逻辑电路记忆先前的输入信息。这种记忆称为逻辑的状态
    + 时许逻辑电路很难分析，并用以产生设计错误，所以我们只关心小部分成熟的模块。需要掌握的最重要元器件就是触发器，它接收时钟和输入$D$，产生一个输出$Q$。触发器在时钟的上升沿将$D$复制到$Q$，其他时候保持$Q$原来的状态。共享一个公共时钟的触发器称为寄存器。触发器还可以接收复位和使能控制信号。
    + 虽然有多种形式的时许逻辑，但我们只考虑最容易设计的同步时许逻辑电路。同步时许逻辑电路包含由时钟驱动寄存器隔开的组合逻辑块。电路的状态存储在寄存器中，仅在时钟沿到达时进行更新。
    + 同步时许逻辑电路的时序规范包括时钟到$Q$的传播延迟$t_{pcq}$和最小延迟$t_{ccq}$，建立时间$t_{setup}$和保持时间$t_{hold}$。为了正确操作，它们的输入在孔径时间内必须稳定。孔径时间在时钟的上升沿之前启动建立时间，在时钟的上升沿之后结束保持时间。系统的最小延迟周期$T_c$等于通过组合逻辑块的传播延迟$t_{pd}$加上寄存器的$t_{pcq}+t_{setup}$。为了正确操作，通过寄存器和组合逻辑的最小延迟必须大于$t_{hold}$。与常见的误解相反，**保持时间不影响周期时间**

14. 锁存器：当时钟为$HIGH$时，$D$锁存器是透明的，允许数据从输入流向输出。当时钟为$LOW$时锁存器变为不透明的，保持原来的状态。不是所有的综合工具都能很好地支持锁存器。除非你知道工具支持锁存器，或者你有理由使用它们，否则，最好不使用他们而使用边沿触发器。$always\_latch$等同于$always @ (clk,d)$ ,它是$system\ verilog$中用来描述锁存器的首选风格. 

    $always\_comb$等同于$always\ @(a)$，但比$always@(a)$更好，因为它避免了在$always$语句中由于信号改名或添加信号所带来的错误。  

### 数字模块

1. **半加器**：半加器有两个输入$A$和$B$，两个输出$S$和$C_{out}$.$S$是$A$和$B$的和，$C_{out}$是进位
2. **全加器**：多了接收进位$C_{in}$ 
3. **进位传播加法器**：一个$N$位加法器将两个$N$位输入$(A、B)$和一位进位$C_{in}$相加，产生一个$N$位结果$S$和一个输出进位$C_{out}$。
   + 行波进位加法器：构造$N$位进位传播加法器的最简单方法就是把$N$个全加器串联起来。其中一级的$C_{out}$就是下一级的$C_{in}$。这是规模化和规整化的一个应用范例：全加器模块在一个更大的系统中被多次重用。行波进位加法器有一个缺点：当$N$比较大时，运算速度会慢下来，因为后一级的输入依赖于前一级的输出
   + 先行进位加法器：是另一种类型的进位传播加法器，它解决进位问题的方法是：把加法器分解成若干块，同时增加电路，当每块一有进位时就快速确定此块的输出进位。因此它不需要等待进位行波通过一块内的所有加法器，而是直接先行经过该块。当$N \gt 16$时，先行进位加法器一般比行波进位加法器快很多。然而，加法器的延迟依然随$N$线性增长。
   + 前缀加法器：扩展了先行进位加法器的产成和传播逻辑，可以进行更快的加法运算。前缀加法器的延迟以加法器位数的对数增长，而不是线性增长。它明显提高了速度，特别当加法器位数超过$32$位时，但是，它比简单的先行进位加法器需要消耗更多的硬件资源。

4.  **减法**：改变减除的符号，然后做加法。为了计算$Y=A-B$，首先创建减数$B$的二进制补码，。反转$B$的所有位得到$\overline{B}$，然后加$1$得到$-B=\overline{B}+1$。把这个值与被减数$A$相加得到最后的值。
5. **算数逻辑单元**：将多种算术和逻辑运算组合到一个单元内。例如：典型的算术逻辑单元可以执行加法、减法、量值比较、$AND$和$OR$计算。$ALU$是大多数计算机的核心。
6. **移位器和循环移位器**：用于移动位并完成$2$的次幂的乘法或者除法。
   + **逻辑移位器**——左移或者右移书，以$0$填充空位
   + **算数移位器**——以逻辑移位器一样，但算数右移时会把原来数据的最高有效位填充在新数据的最高有效位上，这对有符号数的乘法除法很有用。算数左移与逻辑左移一样。
   + **循环移位器**——循环移动数字，这样从一端移走的位重新填充到另一端的空位上。

7. ```verilog
   //计数器 system verilog
   mdoule counter#(parameter N=8)
   (input logic clk,
   input logic reset,
    output logic [N-1:0] q);
   always_ff @(posedge clk,posedge reset)
       if(reset) q<=0;
   	else q<=q+1;
   endmodule 
   ```

8. ```verilog
   //移位寄存器（可以看作串行到并行转换器）
   module shiftreg #(parameter N=8)
       (input logic clk,
       input logic reset,load,
       input logic sin,
        input logic [N-1:0] d,
        output logic [N-1:0] q,
        output logic sout);
       always_ff @(posedge clk,posedge reset)
           if(reset) q<=0;
       else if (load) q<=d;
       else 			q<={q[N-2:0],sin};
       assign sout = q[N-1];
   endmodule
   
   ```

9. **扫描链**：通过扫描链技术，移位寄存器经常用于测试时序电路。

10. **存储器**：存储器由一个二维存储器单元阵列构成。存储器可以读取或者写入内容到阵列的一行。这行由*地址* 指定。读出或者写入的值称为*数据* 。一个有$N$位地址和$M$位数据的阵列有$2^N$行和$M$列。每行数据称为一个**字(word)**。因此阵列包含了$2^N$个$M$位字。阵列的*深度* 是行数，*宽度* 是列数，也称为字大小。阵列的大小就是*深度 x 宽度* 。

    1. **位单元**：存储器阵列由位单元的阵列组成，其中每个位单元存储$1$ 位数据，。一个位单元与一个*字线* 和一个 *位线* 相连。对于每一个地址位的组合，存储器将字线设置位高电平，并激活此行中的位单元。当字线为高电平时，就从位线传出或者传入要存储的位。否则，位线就与位单元断开。为了读位单元，位线初始化位浮空。然后，字线打开为高电平，允许存储的值驱动位线为0或者1。为了写位单元，位线强制驱动为期望要输出的值，然后，字线打开为高电平，将位线链接存储位。强制驱动使得位线将改写位单元的内容，将期望的值写入存储位。

    2. **存储端口**：所有存储器都有一个或者多个端口，每一个端口提供对一个存储器地址的读/写访问。多端口存储器可以同时访问多个地址。

    3. **存储器类型** $RAM$的两种类型包括：*动态*$RAM$ 和*静态* $RAM$.动态$RAM$以电容充放电来存储数据，静态$RAM$使用交叉耦合的反向器来存储数据。

    4. $2^N字\times M$位的$RAM$

       ```verilog
       module ram #(parameter N=6,M=32)
           (input logic clk,
           input logic we,
            input logic [N-1:0] adr,
            input logic [M-1:0] din,
            output logic [m-1:0] dout);
           logic [M-1:0] mem[2**N-1:0];
           always_ff @(posedge clk)
               if(we) men[adr]<=din;
           assign dout = mem[adr];
       endmodule
       ```

    5. 4字$\times$3位$ROM$ 

       ```verilog
       module rom(input logic [1:0] adr,
                  output logic [2:0] dout);
           always_comb
               case(adr)
                   2&#39;b00:dout&lt;=3&#39;b011;
                   2&#39;b01:dout&lt;=3&#39;b110;
                   2&#39;b10:dout&lt;=3&#39;b100;
                   2&#39;b11:dout&lt;=3&#39;b010;
               endcase
       endmodule##
       ```

#### 《数字设计和计算机体系结构》数字设计部分完结，体系结构部分跳过

---

---

---









##  The ZYNQ Book  笔记

1. $Zynq$的总的架构包含了两个部分：处理器系统$(PS)$和可编程逻辑$(PL)$。这两个部分可以单独使用，也可以合起来用，而实际上供电电路被设计成独立给每个部分供电，这样$PS$和$PL$部分不被使用的话就可以被断电。

2. 处理器系统

   + 应用处理器单元$(APU)$：$APU$主要由两个$ARM$处理器核组成，每个都关联了一些可计算的单元：一个$NEONTM$媒体处理引擎$(Media\ Prosessing\ Engine,\ MPE)$和浮点单元$(Floating\ Point\ Unit,\ FPU)$ ；一个内存管理单元$(Memory\ Management\ Unit,\ MMU)$；和一个一级$cache$存储器（分为指令和数据两个部分。$APU$里还有一个二级$cache$存储器，再往下还有片上存储器$(On\ Chip\ Memory,OCM)$。最后，由一个一致性控制单元$(Snoop\ Contro\ Unit,SCU)$在$ARM$核和二级$cache$及$OCM$存储器之间形成了桥连接，这个单元还部分负责与$PL$对接。

   + 根据具体型号，其中的$ARM\ Cortex-A9$最高工作频率可达到$1GHz$。两个核中的任意一核分别包含一个一级数据$cache$和一个一级指令$cache$,每个都是$32KB$.一般情况下，这样就能在本地存储常用的数据和指令，实现快速的访问时间和优化的处理器性能。两个核另外还共用一个$512KB$的二级$cache$来存放指令核数据，再往下在$APU$里还有一个$256KB$的片上存储器。$MMU$的主要责任是在虚拟地址和物理地址之间做翻译。
   + 一致性（窥视）控制单元$(SCU)$从事的是一些和两个处理器与一二级$cache$存储器之间的接口相关的任务。$SCU$负责维持两个处理器的数据$cache$存储器和共享的二级$cache$存储器之间的存储一致性。它还初始化并控制对二级$cache$的访问，在必要的时候仲裁从两个核来的访问请求。$SCU$还要通过加速器一致端口$(Accelerator\ Coherency\ Port,ACP)$来管理在$PS$和$PL$之间的访问会话。
   + 作为主$ARM$处理器的附加功能，$NEON$引擎实现了单指令多数据$(Single\ Instruction\ Multiple\ Data,SIMD)$功能来实现媒体和$DSP$类算法的战略加速。$NEON$指令是对标准$ARM$指令集的扩展，可直接使用，也可通过写出遵循特定格式的$C$代码，让编译器产生$NEON$指令。$SIMD$术语意味着$NEON$引擎可以对输入向量中的多组数据同时执行相同的运算来得到对应的输出向量。这种计算范式很好地迎合了像图像和视频处理这样的应用，可以同时对大量的数据样本（像素点）做运算，也适合天生具有并行性的常用的信号处理哈数，比如有限脉冲相应$(FIR)$滤波和快速傅里叶变换$(FFT)$.
   + $NEON$支持多种数据类型，包括有符号和无符号的整数、单精度浮点数和半精度浮点数，但是不支持双精度。如果需要双精度计算，要用到浮点数单元。

####  $Zynq-7000$是特地使用了$ARM Cortex-A9$的 $r3p0$ 版本，基于$V7-A$架构

3. 可编程逻辑

   1. 逻辑部分：$PL$特性

      + 可配置逻辑块$(CLB)$——$CLB$ 是逻辑单元的小规模、普通编组，在$PL$中排列位一个二位阵列，通过可编程互联连接到其他类似的资源，每个$CLB$里包含两个逻辑片，并且紧邻一个开关矩阵

      + 片$Slice$——$CLB$里面的一个子单元，里面有实现组合和时序逻辑电路的资源，$Zynq$的片是由$4$个查找表、$8$个触发器和其他一些逻辑所组成的

      + 查找表$(Lookup\ Table,\ LUT)$——一个灵活的资源，可以实现

        1. 至多$6$个输入的逻辑函数
        2. 一小片只读存储器$(ROM)$
        3. 一小片随机访问存储器$(RAM)$
        4. 一个移位寄存器

        $LUT$可以按需组合起来形成更大的逻辑函数、存储器或移位寄存器

      + 触发器$(Filp-flop,FF)$——一个实现$1$位寄存器的时序电路，带有复位功能。$FF$的一种用处是实现所存
      + 开关矩阵$(Switch\ Matrix)$——每个$CLB$旁都有一个开关矩阵，实现灵活的布线功能来（一）链接$CLB$内的单元；或（二）把一个$CLB$与$PL$内的其他资源连接起来。
      + 进位逻辑$(Carry\ Logic)$——算术电路需要在相邻的片之间传递信号，这就是通过进位逻辑来实现的。进位逻辑把布线和复用器组成链条来链接一个垂直列上的片
      + 输入/输出块$(Input/Output\ Block,\ IOB)$——$IOB$实现了$PL$逻辑资源之间的对接，并且提供物理设备"焊盘"来链接外部电路。每个$IOB$可以处理每一位的输入或输出信号。$IOB$通常位于芯片的周边。

   2. 特殊资源：$DSP48E1$和块$RAM$ 
      + 除了通用的部分，还有两个特殊用途的部件：满足密集存储需要的块$RAM$和用于高速算数的$DSP48E1$片。这两个资源都按列集成在逻辑阵列中，嵌入在逻辑部分中，往往彼此靠近。
      + $Zynq-7000$里的块$RAM$和$Xilinx\ 7$系列$FPGA$里的那些块$RAM$是相同的，它们可以实现$RAM$、$ROM$和先入先出$(FIFO)$缓冲器，同时还支持纠错编码$(ECC)$.

   3. 通用输入/输出：$Zynq$上的通用输入/输出功能$(IOB)$合起来被称作$SelectIO$资源，它们被组织成$50$个$IOB$一组。每个$IOB$有一个焊盘，是于外部世界连接起来做单个信号的输入或输出的。每个$IOB$还包含一个$IOSERDES$资源，可以做并行和串行数据的可编程转换，数据可以是$2$位到$8$位的。
   4. 通信接口：$Zynq$芯片里面含有嵌入在逻辑部分里的$GTX$收发器和高速通信接口块，支持 一些标准的接口，包括$PCI\ Express$、串行$RapidIO$、$SCSI$和$SATA$.
   5. 其他可编程逻辑扩展接口：
      + **模拟-数字转换**——$PL$还具有其他的硬$IP$部件：$XADC$块。这是一个专用的模拟-数字转换器混合信号硬件，具有两个独立的12位ADC，每个可以以$1Msps$对外部模拟输入信号采样。
      + **时钟**——$PL$接收来自$PS$的四个独立的时钟输入，另外还能产生和分发他自己的与$PS$无关的时钟信号。
      + **编程与调试**——在$PL$部分实现了一组$JTAG$端口来实现对$PL$的配置和调试

4. 处理器系统和可编程逻辑的接口

   $Zynq$的表现不仅仅依赖于它的两个组成部分$PS$和$PL$的特性，还在于能把两者协同起来形成完整、集成的系统的能力。这其中起关键作用的，是一组高度定制的$AXI$互联和接口用来在两个部分之间形成桥梁。另外，在$PS$和$PL$之间还有一些其他类型的连接，特别是$EMIO$。

   1. $AXI$标准
      + $AXI4$——用于存储映射连接，它支持最高的性能，通过一簇高达$256$个数据字（或”数据拍（data beats）“）的数据传输来给定一个地址。
      + $AXI-Lite$——一种简化了的链接，只支持每次连接传输一个数据（非批量）。$AXI4-Lite$也是存储映射的，在这种协议下每次传输一个地址和单个数据。
      + $AXI4-Stream$——用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流（非存储器映射）

   2. $AXI$互联和接口
      + **互联**——互联实际上是一个开关，管理并直接传递所连接的$AXI$接口之间的通信。在$PS$内有几个互联，其中有些还直接连接到$PL$，而另一些是只用于内部连接的。这些互联之间的连接也是用$AXI$接口所构成的
      + **接口**——用于在系统内的主机和从机之间传递数据、地址和握手信号的点对点之间连接
      + 所有接口都明确的连接到$PS$内的$AXI$互联，唯一例外的是$ACP$接口，它直接连到$APU$里面的一致性控制单元$(SCU)$。
      + **通用AXI**——一条$32$位数据总线，适合$PL$和$PS$之间的中低速通信。接口是透传的不带缓冲。总共有四个通用接口：两个$PS$做主机，另两个$PL$做主机
      + **加速器一致性端口**——在$PL$和$APU$内的$SCU$之间的单个异步连接，总线宽度位64位，这个端口用来实现$APU\ cache$和$PL$的单元之间的一致性。$PL$是做主机的
      + **高性能端口**——四个高性能$AXI$接口，带有$FIFO$缓冲来提供"批量"读写操作，并支持$PL$和$PS$中的存储器单元 的高速率通信。数据宽度是32或64位，在所有四个接口中$PL$都是做主机的。
   
   3. EMIO接口——从$PS$出来，有几个连接可以经由$PL$到外部接口上，这被称作扩展的$MIO$，即$EMIO$.
   4. 其他PS-PL信号——跨越$PS-PL$边界的其他信号包括看门狗定时器、重启信号、中断和$DMA$接口信号。

5. 安全
   1. 安全引导——$Zynq-7000$芯片的引导方法只限于一种来源——芯片引导必须由处理器驱动。当芯片上电或重启的时候，$PS$的第一个核从外部存储器中引导，然后才会去配置$PL$.通过限制引导的方法为单一来源，就确保了就不可能在$PL$已经配置之后再有人工的方法来装在恶意的软件，同时在处理器已经初始化之后再也没有办法再装载恶意的映像到$PL$中去。
   2. 硬件支持——所有芯片都受益于内置的硬件安全$IP$，这个安全$IP$既可以是$PS$内的硬$IP$包，也可以是$PL$内的软$IP$。下面列出了$Zyqn$芯片和安全有关的一些特性：
      + $ARM\ TrustZone$支持
      + $AES-256$加密
      + 安全认证和启动
      + $HMAC$位流认证
      + $FSBL\ RAS-2048$认证
      + 禁止强硬回读
      + $JTAG$禁止/监视
      + $SEU$检查器

6. 在选择芯片时所涉及的因素

   | 分类         | 因素                                                         |
   | ------------ | ------------------------------------------------------------ |
   | 芯片能力     | 处理器性能<br />逻辑性能<br />存储器性能<br />支持高速算数<br />支持$I/O$和通信<br />安全特性和逻辑部分之间的带宽<br />处理器和逻辑部分之间的延迟 |
   | 商业因素     | 物料表<br />开发成本<br />集成(和隐形成本)<br />芯片供应的长期性和技术支持<br />质量和可靠性<br />实现现场升级的容易程度(和成本) |
   | 设计和开发   | 进入市场的时间<br />快速、便捷和可靠的设计流<br />集成的验证<br />与其他开发工具的集成<br />支持团队设计流<br />支持设计重用<br />支持工业标准的设计格式<br />支持所需的设计入口方法<br />文档和技术支持 |
   | 芯片物理特性 | 物理尺寸<br />功耗<br />易于集成和生产的PCB的复杂程度<br />可连接性<br />耐久性<br />是否对辐射敏感<br />支持的温度范围 |
   | 灵活性       | 可伸缩性（有更大或更小的芯片，而且只需要很小的甚至不需要工作就可以调整<br />可移植性(用标准格式设计可以移植到其他平台或从其他平台移植过来)<br />再编程能力(可以现场甚至在运行时刻动态改变功能)<br />易于划分(能在硬件和软件之间划分功能)<br />可扩展性(易于集成新的功能) |


7. 处理器$cache$——$cache$是一小块位于$CPU$和主存储器之间的存存储器。它具有比存储器低的访问时间，而且不能通过系统总线访问。
   +  在进一步讨论$cache$的不同级别之前，首先应该来介绍要用到的两种类型的存储器——动态$RAM(DRAM)$和静态$RAM(SRAM)$.
   + 动态$RAM(DRAM)$：是在计算机系统中最常见的存储器类型。$DRAM$芯片包括大量的存储单元，每个单元用电容保存1位的数据。每个存储单元还配有一个晶体管，它像一个开关一样让控制电路可以读或写这个电容的状态。由于电容和晶体管都极为微笑，单个$DRAM$芯片中可以放百万个独立的存储单元。由于电容会自己漏电，每个存储单元所保存一位的数据的状态最终会消失，除法这个电容上的电荷能周期性地被存储控制器所刷新。存储控制器通过读每个存储单元的 状态然后再写回去实现这个刷新。这正是动态$RAM$得名的由来。
   + 静态$RAM(SRAM)$：$SRAM$采用与 $DRAM$不同的技术来保存数据。$DRAM$的每一位是存储在电容中的，而$SRAM$用了锁存器来保存数据。每个存储单元需要4或6个锁存器来保存数据的一个位，因此比$DRAM$需要更多的芯片面积，从而导致它更贵。$SRAM$的好处是不需要刷新，因此比$DRAM$块很多。由于$SRAM$的高价，通常只用于高速、低容量的存储芯片中。
   +  $1级(L1)\ Cache$：是最小的$cache$存储器，典型的大小是8到128kb。它是以在处理器核心所在的硅片上的$SRAM$来实现的，因此具有与处理器相同的时钟速度。$L1\ cache$通常分成两个部分：数据$cache$和指令$cache$。 $L1\ cache$用来保存常用数据和指令的本地拷贝，使得处理器能瞬间访问它们。
   + $2级(L2)cache$：通常独立于处理器核心之外，但是离得非常近。它比$L1\ cache$大，通常在256到1024kb之间，但是访问速度较慢。$L2\ cache$是DRAM的形式，只有同一的一块区域（不像L1那样分成两块区域）。较大量的数据会不断地由主存储器读入$L2\ cache$，然后再馈送给$L1$.
   + $3级(L3)cache$：是再所有的处理器核心之间共享的，它也是$DRAM$的形式，是最大的$cache$存储器，通常具有$2MB$甚至更大的容量。

8. 执行周期：为了让一个保存在存储器中的程序能被处理器执行，程序必须经过一个执行周期。指令周期所用到的术语：

   + **机器码**——在写软件程序的时候，通常都是高级语言，这种语言易于被程序员所理解，而且是人可读的。这种形式的代码对于处理器系统是无意义的，必须被转换，或者说编译成处理器可以理解的形式。这最后的低级的能被处理器所阅读的输出结果就是机器码——一串和程序相关的、处理器能够解释和操作的二进制数据
   + **操作码**——一个操作码是一个运算编码，唯一地定义了要做的一个功能——一条机器码代表了一个处理器指令。一个处理器可以执行许多不同的运算，因此每条指令都被指定了唯一的数字编码。
   + **CPU指令集**——某个处理器的指令集是处理器能理解的命令的基本合集。它包含了每个操作码的定义和可以由处理器执行的本地命令

   1. **取指**：是指令执行周期的第一个阶段。具体流程是
      1. 程序计数器寄存器里有表示存储器里要执行的下一条执行的地址
      2. 这个值被传送给 存储器的地址寄存器，在那里，控制单元检查这个值并从寄存器中获得想用的指令。
      3. 那条指令于是就被保存在存储器缓冲寄存器中，然后再被传输给指令寄存器
      4. 控制单元改变程序计数器寄存器，让它的值符合下一条要执行的指令的地址

   2. **译码指令**：一旦指令被从寄存器中取出，下一步就是把指令变成处理器能够理解的形式。这就是译码阶段。在这个时刻，控制单元检查保存再指令寄存器里的指令。这个检查识别出操作码和所用的寻址方式，以及接下来需要执行什么动作来正确地执行这条指令。变成处理器能够理解的形式。这就是译码阶段。在这个时刻，控制单元检查保存再指令寄存器里的指令。这个检查识别出操作码和所用的寻址方式，以及接下来需要执行什么动作来正确地执行这条指令。
   
      主要有三种寻址方式：
   
      + **立即寻址**——这是不需要找数据的，因为所有要用到的数据都在指令的操作数部分里了。因此立即寻址是最快的，但是最不灵活的方式
      + **直接寻址**——指令的操作数部分包含了所需的数据的存储器地址。所需的数据必须从这个地址获得
      + **间接寻址**——指令的操作数包含了一个存储器地址。在这个地址上的存储器内容是一个指向所需数据地址的指针。因此间接寻址是最灵活的，但是由于要做两次数据查找，所以也是最慢的
   
   3.  **执行指令**：根据译码阶段所决定的操作码，在这个阶段可能做出各种不同的动作。总的来说有四大类动作：
      + 在处理器和存储器之间传输数据
      + 在处理器和$I/O$设备之间传输数据
      + 处理数据，比如用算数逻辑单元
      + 会改变后续操作的顺序的控制操作。这些可能是基于某个标志寄存器的值的条件操作
   
   一旦指令被执行了，下一条要处理的指令就被取了过来

9. 中断：硬件中断可以进一步被分类为以下几个类型：
   + **可屏蔽中断(IRQ)**——触发可屏蔽中断的事件源不总是重要的。程序员需要决定这个事件是否应该导致程序跳转到所需要处理的地方去。可能使用可屏蔽中断的设备包括定时器、比较器和$ADC$.
   +  **不可屏蔽中断(NMI)**——这些是不应该被忽视的中断，因此绝对比可屏蔽中断重要得多。需要NMI的时间包括上电、外部重启和严重的设备失效
   + **处理器间中断(IPI)**——在多处理器中，一个处理器可能需要中断另一个处理器的操作。在这种情况下，就会产生一个IPI.

10. 总线：实现了处理器和其他处理器及外围设备间的接口。   处理器、存储控制器和外围设备通过标准总线接口连接到总线上。

    1. 系统与外设总线：在较大型的嵌入式系统设计中，可能最好用多个总线来提供所有的处理器和外设之间的足够的通信带宽。**系统总线**、**外设总线**、**总线桥**
    2. 总线主机和从机
    3. 总线仲裁
    4. 存储器访问：一个嵌入式系统中存储控制器的访问方式能极大的影响整体的性能。即便使用了非常高效的存储器类型和存储控制器，系统的性能也会遭受到糟糕的存储访问控制的影响。重要的是系统以能最大化存储带宽的方式来构造和访问，同时保持最小的资源需求。
       + **可编程输入/输出**： 管理存储控制器和其他外设之间的数据移动手段之一，是让所有的数据传输都通过处理器，这样的存储传输叫做可编程I/O，让系统以最少的资源来处理存储传输。这个方法需要外设和处理器位于同一个总线上，处理器成为所有外设和存储器通信的中心点。如果外设和存储器之间的存储传输请求的数量很大，处理器就会花费大量时间来做存储传输，那么做其他计算的时间就少了。如果系统在可编程逻辑中实现大多数功能，那么可编程I/O是能用最少的资源管理存储事务的有效方法。不过，如果处理器需要从事大量其他计算，其他的方法也许更好
       + **直接访问控制(DMA)**：降低 处理器负担的一种办法是用直接存储器访问来做存储传输。用了这个方法，处理器像DMA控制器发出一个存储传输请求，然后DMA控制器将来做这个存储事务。这样当DMA控制器在做传输的时候，处理器就可以从事其他任务了。在这中情况下，DMA控制器既是总线主机也是总线从机。为了发起传输事务，DMA控制器必须得到以下数据：
         + 源地址——数据将要被读出的地址
         + 目的地址——数据应该被写入的地址
         + 传输长度——应被传输的字节数

    5. 总线带宽：总线带宽是总线上一定的单位时间内可以传输的总的数据量。总线带宽的值取决于两个因素：

       + 总线数据宽度——这是总线同时传输数据的物理的线路的数据量。32位独立数据线的总线可以同时传输32位的数据

       + 总线频率——这是总线操作的速度。这指的是每秒总线可以发送/接收的数据位的数量，是以赫兹位单位

         $Bus\ Bandwidth(Mbits/s)\ =\ Bus\ Width(bits)\ \times\ Bus\ Frequency(MHz)$ 

11. 存储器接口：所有$Zynq-7000$芯片上的存储器接口单元包括一个动态存储器控制器和几个静态存储器接口模块。动态存储器控制器可用于$DDR3$、$DDR3L$、$DDR2$、$LPDDR2$。静态存储器控制器支持一个$NAND$闪存接口、一个$Quad-SPI$闪存接口、一个并行数据总线和并行$NOR$闪存接口。

12. **AMBA Overview**

    | key  AMBA Specification                                      | AMBA2 | AMBA3    | AMBA4                   | AMBA5     |
    | ------------------------------------------------------------ | ----- | -------- | ----------------------- | --------- |
    | **CHI** Coherent Hub Interface<br />CHI is credited coherency protocol,<br />layer architecture for scalability |       |          |                         | CHI       |
    | **ACE** AXI coherency Extensions<br />ACE is superset of AXI-brings system-wide<br />coherency across multicore cluster |       |          | ACE+Lite                | ACE5+Lite |
    | **AXI** Advanced eXtensible Interface<br />AXI supports separate A/D phase,bursts,multiple<br />outstanding address,OoO responses |       | AXI3     | AXI4+Lite,<br />+Stream | AXI5      |
    | **AHB** Adv. High-performance Bus<br />AHB supports 64/128 bit,multimaster,<br />AHB-Lite for single masters | AHB   | AHB+Lite |                         | AHB5      |
    | **APB** Advanced Peripheral Bus<br />System bus for low b/w peripherals | APB2  | APB3     | APB4                    |           |

    **AMBA**(Advanced Microcontroller Bus Architecture)高级微处理器总线架构——定义了高性能嵌入式微控制器的通信标准，可以将RISC处理器集成在其他IP芯核和外设中，它是有效连接IP核的”数字胶“，并且是ARM复用策略的重要组件，它不是芯片与外设之间的接口，而是ARM内核与芯片 上其他元件进行通信的接口。主要包括：

    + AHB：高级高性能总线
    + ASB：高级系统总线
    + APB：高级外设总线
    + AXI：高级可扩展接口

    | 总线     | AXI                                                          | AHB                                                          | APB                                                  |
    | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
    | 总线宽度 | 8,16,32,64,128,256,512,1024                                  | 32,64,128,256                                                | 8,16,32                                              |
    | 地址宽度 | 32                                                           | 32                                                           | 32                                                   |
    | 通道特性 | 读写地址通道、读写数据通道均独立                             | 读写地址通道共用读写数据通道                                 | 读写地址通道共用读写数据通道<br />不支持读写并行操作 |
    | 体系结果 | 多主/从设备<br />仲裁机制                                    | 多主/从设备<br />仲裁机制                                    | 单主设备(桥)/多从设备<br />无仲裁                    |
    | 数据协议 | 支持流水/分裂传输<br />支持突发传输<br />支持乱序访问<br />字节/半字/字<br />大小端对齐<br />非对齐操作 | 支持流水/分裂传输<br />支持突发传输<br />支持乱序访问<br />字节/半字/字<br />大小端对齐<br />不支持非对齐操作 | 一次读/写传输占两个时钟周期<br />不支持突发传输      |
    | 传输方式 | 支持读写并行操作                                             | 不支持读写并行操作                                           | 不支持读写并行操作                                   |
    | 时许     | 同步                                                         | 同步                                                         | 同步                                                 |
    | 互联     | 多路                                                         | 多路                                                         | 无定义                                               |

    **AXI**是**ARM AMBA**单片机总线系列中的一个协议。**AMBA**协议是一个开放的片内互联规范标准，能在多主机设计中实现许多控制器和外围设备之间的连接和管理。

    **AXI** 协议特别体现了以下的关键特性：

    + 地址/控制阶段和数据阶段是分开的
    + 用字节闸来实现了非对其数据的传输
    + 只需发布起始地址就能做批量数据传输
    + 数据的读写通道是分离的，可以用来实现低成本的直接存储访问（DMA）
    + 可以指定多个需要处理的地址
    + 通信会话可以乱序完成
    + 为了实现时许收敛，可以方便地加入寄存器

    1. 各种AXI4：有三种AXI4接口类型，每一种都适合各自不同的应用类型：
       + AXI4——最高性能的接口，适合存储器映射的通信，支持每个地址阶段最高256个数据传输周期的批量传输
       + AXI4-Lite——这个接口的轻量级版本，用于存储器映射的单次数据通信绘画。这个版本的好处是简化了的接口占用较少的逻辑部分面积。这个版本不支持批量数据，因此只支持每次传输单个数据
       + AXI4-Stream——它没有地址阶段，因此不是存储器映射，能够做无限制的数据批量大小。为流式数据的传输定义了单个通道，不过支持无数量限制的批量传输。连接只能是从主机到从机，所有如果是需要双向传输的话，两个外围设备都必须是主机/从机兼容类型

    2. AXI架构

       1. 地址通道：读写的地址通道是分离的，能实现会话所需的所有地址和控制数据。这个数据决定了以下AXI协议机制的运作：
          + 批量，每个批次从1到16个数据的传输
          + 批量传输大小为8~1024位
          + 包裹、递增和非递增的批量传输
          + 在系统层面上的cache和缓冲
          + 独占的原子级操作切换或有锁的访问
          + 安全和特权的访问

       2. 写数据通道：写数据通道包括：
          + 一个8~1024位宽的数据总线
          + 每八位数据一个字节道闸，用来在数据总线中识别出有效的字节

       3. 读数据通道：包括一个相同范围的数据总线，另外还有一个读响应通道，用来表明一次读操作完成了
       4. 写响应通道：让从机可以在每个批次完成后，发出一个完成信号，从而向主机表明写操作完成了

### 后续实例和$:Linux$部分讲述太粗略，跳过，$The\ Zynq\ Book$ 完结

***

---

+++

## 高级FPGA设计：结构、实现和优化

1. 采用任意编码方式时，高级工具的优化程度常常不足以满足大多数设计约束的要求。本节主要讨论数字设计中三个主要物理特性的第一个：**速度**。
   + 速度有三种基本定义：**流量(throughput)**、**时滞(latency)**和**时序(timing)**
     + **流量**定义为每个时钟周期处理的数据
     + **时滞**的一般度量是时间或时钟周期
     + **时序**定义为时序元件之间的逻辑延时，当一个设计没有“满足时序”时，意味着关键路径的延时，即触发器之间的最大延时比预定的时钟周期大，这些延时由组合逻辑延时、时钟到输出延时、布线延时、建立时间、时钟偏移等组成。时序的标准度量是时钟周期和频率

```verilog
//按照软件形式展开，递归
module a(
			output [7:0] XPower,
			output finished,
			input  [7:0] X,
			input  clk,start);
    
			reg [7:0] ncount;
			reg [7:0] XPower;
			
			assign finished = (ncount == 0);
			
			always @ (posedge clk)
			if(start) begin
				XPower <= X;
				ncount <= 2;
			end
			else if(!finished) begin
				ncount <= ncount - 1;
				XPower <= XPower * X;
			end
endmodule
//将上述改成流水线结构
module a(
			output reg [7:0] XPower,
			input clk,
			input [7:0] X);
			
			reg [7:0] XPower1,XPower2;
			reg [7:0] X1,X2;
			
			always @(posedge clk) 
			begin
				X1 <= X;
				XPower1 <= X;
				
				X2 <= X1;
				XPower2 <= XPower1 * X1;
				XPower <= XPower2 * X2;
			end
endmodule
//除去上述的流水线寄存器，使输入到输出的时序最小化
module a(
			output [7:0] XPower,
			input [7:0] X);
			
			reg [7:0] XPower1,XPower2;
			reg [7:0] X1,X2;
			
			assign XPower = XPower2 * X2;
			
			always @ * 
				begin
					X1 = X;
					XPower1 = X;
				end
			
			always @ *
				begin
					X2 = X1;
					XPower2 = XPower1 * X1;
				end
endmodule
```

2. **时序**：指的是一个设计的时钟速度。在设计中任何两个时序元件之间的最大延时将决定最大的时钟速度。时钟速度的概念比速度/面积权衡有更低层次的抽象，因为时钟速递一般不直接与这些拓扑有关，虽然在这些结构中的权衡将确实对时序有影响

   + 最高速度或最大频率可以直接按照著名的最大频率方程定义（不管时钟到时钟的抖动）：

     $F_{max}=\frac{1}{T_{clk-q}+T_{logic}+T_{routing}+T_{setup}-T_{skew}}$

     其中$F_{max}$是时钟可允许的最大频率，$T_{clk-q}$是时钟到达直至数据到达$Q$端的时间，$T_{logic}$是逻辑通过触发器之间的传播延时，$T_{routing}$是触发器之间的布线延时，$T_{setup}$是下一个时钟上升沿之前数据必须到达$D$端的最小时间(建立时间)，$T_{skew}$是启动触发器和捕捉触发器之间时钟的传播延时。

   + 一个乘法器和一个加法器组成的关键路径比最小时钟周期的要求大你，假设时滞要求不固定在一个时钟周期，添加额外的中间寄存器到此乘法器，使设计进一步流水线。

     ```verilog
     module a(
     			output [7:0] Y,
     			input [7:0] A,B,C,X,
     			input clk,
     			input validsample);
     			
     			reg [7:0] X1,X2,Y;
     			
     			always @ (posedge clk)
     				if(validsample)
     					begin
     						X1 <= X;
     						X2 <= X1;
     						Y <= A * X + B * X1 + C * X2;
     					end
     endmodule
     //假设上述FIR实现的结构不满足时序要求，则在乘法器和加法器之间添加一个流水线层次
     module a(
     			output [7:0] Y,
     			input [7:0] A,B,C,X,
     			input clk,
     			input validsample);
     			
     			reg [7:0] X1,X2,Y;
     			reg [7:0] pord1,pord2,pord3;
     			
     			always @ (posedge clk)
     				begin
     					if(validsample)
     						begin
     							X1 <= X;
     							X2 <= X1;
     							pord1 <= A * X;
     							pord2 <= B * X1;
     							pord3 <= C * X2;
     						end
     					Y <= pord1 + pord2 + pord3;
     				end 
     endmodule
     
     ```

     对于流水线乘法器是好的选择，因为计算 可以很容易分解成级。把乘法器和加法器分解成可以单独寄存的级，使附加流水线成为可能。

     **把关键路径分成两个更小延时的路径，添加寄存器层次改进时序**

   + 并行结构

     **把一个逻辑功能分成大量可以并行估计的更小的功能，减少路径延时为子结构的最长延时**

   + 展平逻辑结构

     **去除不需要的特权编码，展平逻辑结构，减少路径延时**

   + 寄存器平衡：平等地重新分布急窜起之间的逻辑，减少任何两个寄存器之间最坏条件的延时。
   + 重新安排路径：可以重新安排与关键路径组合的路径来改善时序，方法是关键路径的一些逻辑放置到接近目的寄存器

3. **面积** 

   + 折叠流水线

     折叠流水线可以优化在流水线级复制逻辑的流水线设计的面积

   + 基于控制的逻辑复用

     当共享逻辑比控制逻辑更大时，控制可以直接用来逻辑复用

.....



+++

## VLSI 数字系统信号处理系统：设计与实现

1. DSP算法：语言编码与解码、语音加密与解密、语音识别、语音合成、调制解调算法、噪声消除、音频均衡、图像压缩和解压缩、波束成形、回声消除。
2. 卷积：两个离散序列$h(n)$和$x(n)$的卷积定义为：$y(n) = x(n)*h(n) = \sum\limits_{k=-\infty}^\infty x(k)h(n-k)$,在时刻$n$的输出$y(n)$可以看作是$x(k)$和$h(-k+n)$的内积(在$-\infty < k < \infty$).
   + 卷积是用来描述和分析线性时不变系统$(Linear$ $Time-Invariant,LTI)$ 的。这种系统可以完全由它们的单位样值（或冲激）响应$h(n)$来描述。一个$LTI$系统的输出序列可以用输入序列$x(n)$以及它的单位样值响应$h(n)$的卷积来计算。如果一个系统的单位样值响应由有限个非零值组成，即$h(n)$有限长，那么该系统称为有限冲激响应$(Finite$ $Impulse$ $Response$, $FIR)$。如果$h(n)$具有无限长度，该系统则称为无限冲激响应$(Infinie$ $Impulse$ $Response,IIR)$。例如，移动平均系统就是$FIR$系统，它的冲激响应为$h(n) = \frac{1}{M_1+M_2+1} \sum\limits_{-M_1}^{M_2} \delta(n-k)$，累加器的单位样值响应为：$h(n) = \sum\limits_{k=-\infty}^{\infty} \delta(k)$ 它是一个$IIR$系统。该系统是一个阶跃函数，当$n \ge 0$时等于$1$,当$n \lt 0$时等于$0$。 
   + 如果$y(n_0)$的计算只与过去的采样值$x(k)(k\le n_0)$相关，那么则该系统是因果$(Causal)$的。对于一个因果的$LTI$系统，单位样值响应应满足当$n \lt 0$时$h(n) = 0$。我们只对因果的数字滤波器感兴趣，因为非因果的系统无法用硬件或者软件实现。





## Verilog相关/无线通信FPGA设计

1. ^ 异或，^ 同或，~& 与非，~~| 或非。

2. 门类型关键字：and,nand,nor,or,xor,buf,not

3. 可以简单把任务理解成返回类型的void的子程序，把函数理解成为带有返回值的子程序。

   + 任务类似于高级编程中的“过程”，支持多种功能，能计算多个结构值，并通过被调用任务的输出形式送出。任务可以启动别的任务和函数，且可启动的任务数是没有限制的。不管有多少任务启动，只有所有任务完成后控制才能返回。

     + 任务的定义：任务定义的语法为：

       task<任务名>;

       ​	<端口与类型说明>

       ​	<局部变量说明>

       ​	begin

       ​		<语句1:>

       ​		......

       ​		<语句n:>

       ​	end

       endtask

       任务定义结构不能出现在任何一个过程块的内部。在第一行“task”语句中不能列列出端口列表；可以没有输入、输出端口和双向端口，也可以有一个或多个输入、输出端口和双向端口。

     + 任务的调用：<任务名>(端口1，端口2，...端口n)；

       任务调用只能在过程块中进行，就像一条普通行为语句那样得到处理。当被调用的任务具有输入或输出端口是，任务调用语句必须包含端口列表。这个列表内端口出现的顺序和类型必须与任务定义的顺序和类型一致。

   + 函数(function):函数的目的是通过返回一个值来响应输入信号的值。函数不能启动任务，但任务可以启动函数。在Verilog HDL中函数被当作操作符来使用，结果就是这个函数的返回值。

     + 函数的定义。函数定义的语法为：

       function<返回值的类型和位宽>（）

       ​	<端口与类型的说明>

       ​	<局部变量说明>

       ​	begin

       ​		<语句1：>

       ​		....

       ​		<语句n：>

       ​	end

       endfunction

       其中，<返回值的类型和位宽>是可选项，如果缺省将返回一位寄存器类型的数据，也可以只写位宽。

       Verilog HDL认为函数的定义中隐式地声明了与函数同名的寄存器。函数的定义把函数返回值所赋值寄存器的名称初始化为与函数同名的内部变量。例如

       ```verilog
       function [15:0] plusplus;
           input [15:0] a;
           begin
               plusplus = a + 1;
           end
       endfunction
       ```

       其中，plusplus被赋予的值就是函数的返回值。

       + 函数的调用

         函数的调用时通过将函数作为表达式中的操作数来实现的，调用格式为：

         ​	<函数名>(<输入表达式1>,<输入表达式2>,...<输入表达式n>);

         其中，n个<输入表达式>要与函数定义结构中说明的各个端口一一对应，它们代表各个输入端口的输入数据，这些输入表达式的排列顺序及类型必须与各个输入端口在函数定义结构中的排列顺序及类型保持严格一致。

         需要注意的是，函数的调用不能单独作为一条语句出现，它只能作为一个操作数出现在赋值语句内，不仅能够用于过程块内的赋值，还能够出现在assign语句中。

         函数调用实例：

         ```verilog
         out = plusplus(input);
         assign a = plusplus(input);
         ```

         综上所述，函数和任务存在以下不同点：

         + 函数至少必须有一个输入端口，而任务可以有多个、一个或者没有输入端口
         + 函数不能有输出端口，而任务可以有多个、一个或者没有输出端口
         + 函数调用通过函数名返回一个返回值，而任务调用通过端口传递返回值
         + 函数中不能调用任务，而在任务中可以调用函数
         + 函数调用不能作为一条语句出现，而任务调用则可以
         + 函数调用可以出现在过程块或者连续赋值语句中，而任务调用只能出现在过程块中。

4. 提高系统速度的方法：其一是采用并行方式设计，其二是采用流水线设计方式。

   ```verilog
   //非流水线全加器
   module adder8(cout,sum,clk,cina,cinb,cin);
       input [7:0] cina,cinb;
       input clk,cin;
       output [7:0] sum;
       output cout;
       reg [7:0] sum;
       reg cout;
       always @ (posedge clk) begin
           {cout,sum} = cina+cinb+cin;
       	end
   endmodule
   //二级流水线
   module adder8_2(cout,sum,clk,cina,cinb,cin);
       input [7:0] cina,cinb;
       input clk,cin;
       output [7:0] sum;
       output cout;
       reg cout;
       reg cout1;
       reg [3:0] sum1;
       reg [7:0] sum;
       always@(posedge clk) begin //第4位相加
           {cout1,sum1} = cina[3:0] + cinb[3:0] +cin;
       end
       always@(posedge clk) begin //高4位相加并且将8位拼接起来
           {cout,sum} = {{cina[7],cina[7:4]} + {cinb[7],cinb[7:4]+cout1},sum1};
       end
   endmodule
   //四级流水线
   module adder8_4(cout,sum,clk,cina,cinb,cin);
       input [7:0] cina,cinb;
       input clk,cin;
       output [7:0] sum;
       output cout;
       reg out;
       reg cout1,cout2,cout3;
       reg [2:0] sum1;
       reg [4:0] sum2;
       reg [6:0] sum3;
       reg [7:0] sum;
       always@(posedge clk ) begin
           {cout1,sum1} = cina[1:0] +  cinb[1:0] +cin;
       end
       always@(posedge clk) begin
           {cout2,sum2} = {{cina[3],cina[3:2]}+{cinb[3],cinb[3:2]}+cout1,sum1};
       end
       always@(posedge clk) begin
           {cout3,sum3} = {{cina[5],cina[5:4]}+{cinb[5],cinb[5:4]}+cout2,sum2};
       end
       always@(posedge clk) begin
           {cout,sum} = {{cina[7],cina[7:6]}+{cinb[7],cinb[7:6]}+cout3,sum3};
       end
   endmodule
   ```

5. 除法器：两个无符号二进制数(如正整数)相除的时序算法是通过“减并移位”的思想来实现的，即从被除数中重复地减去除数，直到已检测到余数小于除数为止。这样可以通过累计减法运算的次数得到商；而玉树是在减法运算结束时被除数中的剩余值。当除数较小时，这种基本电路都必须进行多次减法，因此效率都不高。另一种方法是，在进行两个数相除的运算时，通常采用的步骤是调整除数与被除数使其最高位对齐，然后反复地从被除数中减去除数，并将除数向被除数的最低为移动，且在高效除法器结构中可以并行运行这些操作步骤。而在具体的硬件硬件实现中，是通过将被除数寄存器的内容不断地向除数的最高位移动来完成除法运算的。

6. 傅里叶变换：

   + 连续傅里叶变换$(FFT)$：$X(f)=\int^\infty_{-\infty} x(t)e^{-j2\pi ft} dt$ , $x(t) = \frac{1}{2\pi} \int^{\infty}_{-\infty} X(f)e^{j2\pi ft} dt$  

   + 离散傅里叶变换$(DFT)$：$X[k] = \sum\limits^{N-1}_{n=0} x[n] W^{kn}_{N}$ , $x[n] = \sum\limits^{N-1}_{n=0}X[k]W^{-kn}_{N}$ ,如果用$DFT$对傅里叶变换进行近似，就必须记住在时域和频域上采样的影响，分别是：
     + 时域采样需要满足时域采样定义：即采样频域要高于$x(t)$最高频率的两倍
     + 通过时域采样，时间函数就变成了周期性的，如果对于一个信号采样$N$次采样$DFT$,没有在一个$N$次采样窗完成整数个循环，那么就会产生频率泄露的现象。 

7. $FFT$算法的基本原理

   $FFT$算法的主要核心思想就是将$N$点的序列逐次分解为$(N-1)/2$，直至$2$点的$DFT$。目前的算法可以从时域和频域分别将序列分解成不同的子序列，前者就称为时间抽选法，后者称为频率抽取法。所谓的时间抽选法就是直接将$x(n)$逐次分解成奇数子序列和偶数子序列，通过求子序列的$DFT$而实现整个序列的$DFT$。频率抽选法，是在频域内将$X(k)$逐次分解为偶数点子序列和奇数点子序列，然后对分解越来越短的子序列进行$DFT$运算，就可得整个频域内序列的$FFT$流图。

   1. 时间抽选法 

      假设输入信号的列向量位$x[n]=[x(0),...,x(N-1)]^T$,其$DFT$输出信号列向量为$X[k]=[X(0),...,X(N-1)]^T$。将集合$x[n]$分解为两个交错集合，一个由偶数点组成，另一个由奇数点组成。$X(k)=Y(k)+W^k_N Z(k),k=0,1...,N/2-1$ $X(k+N/2)=Y(k)-W^k_NZ(k),k=0,1,...,N/2-1$.由上式的矩阵方程可以看出。采用相同的矩阵运算，最后仅求和符号不一样。每次计算都将$N$阶矩阵分为两个$N/2$阶进行，一直到最后转化为二阶矩阵。这样发分解运算必须要求$N$是$2$的幂，所以在实际中一般都要确保$N$为2的幂。这类的$FFT$算法被称为基$2FFT$的算法。

    2. 频率抽选法

       在频率内将$X(k)$逐次分解为偶数点子序列和奇数点子序列，然后对分的越来越短的序列进行$DFT$运算。

       $$\begin{bmatrix} {X(0)} \\{X(2)} \\{X(4)} \\{\cdots} \\{X(N-2)} \end{bmatrix}$$ = $$\begin{bmatrix} {1}&{1}&{1}&{\cdots}&{1} \\{1}&{W^2_N}&{W^4_N}&{\cdots}&{W^{N-2}_N} \\{1}&{W^4_N}&{W^8_N}&{\cdots}&{W^{2(N-2)}_N} \\{\vdots}&{\vdots}&{\vdots}&{\ddots}&{\vdots} \\{1}&{W^{N-2}_N}&{W^{2(N-2)}_N}&{\cdots}&{W^{{N-2}^2}_N} \end{bmatrix}$$ $$\begin{bmatrix} {x(0)+x(N/2)} \\x(1)+x(N/2+1) \\x(2)+x(N/2+2) \\{\vdots} \\{x(N/2-1)+x(N-1)} \end{bmatrix}$$ 

       = $\begin{bmatrix} T_{N/2} \end{bmatrix}$ $$\begin{bmatrix}  {x(0)+x(N/2)} \\x(1)+x(N/2+1) \\x(2)+x(N/2+2) \\{\vdots} \\{x(N/2-1)+x(N-1)}  \end{bmatrix}$$ 

       对于奇数点序列，也可以表示为：$$\begin{bmatrix} X(1) \\X(2) \\X(5) \\\vdots \\X(N-1) \end{bmatrix}$$ = $\begin{bmatrix} {1}&{}&{}&{}&{} \\{}&{W_N}&{}&{}&{} \\{}&{}&{W^2_N}&{}&{} \\{}&{}&{}&{\ddots}&{} \\{}&{}&{}&{}&{W^{(N/2-1)}_N} \end{bmatrix}$ $\begin{bmatrix} {x(0)-x(N/2)} \\{x(1)-x(n/2+1)} \\{x(2)-x(n/2+2)} \\\vdots \\{x(N/2-1)-x(N-1)} \end{bmatrix}$ 

       时间抽选法和频率抽选法的计算复杂度相同，二者需要的计算量也相同。时间抽选法需要对输入数据$x[n]$的数据进行重排，频率抽选法输出数据$X[k]$的顺序需要重排。但二者都能同址运算，节省大量的寄存器资源。

8. 数字滤波优点：
   + 数字滤波器的频域特性容易控制，性能指标优良
   + 数字滤波器可以工作在极低的频率，可以方便地实现模拟滤波器难以实现的线性相位系统
   + 数字滤波器工作稳定，一般不会受到外部环境的影响
   + 数字滤波器灵活性和可重用性高，只许简单编程就可以修改滤波器特性，设计周期短。

9. 频域滤波器就是要提取或抑制所分析信号中某些频带的信号成分，如电话网络$DTMF(Dual\ Tone\ Multi-Frequency)$码的识别。时域滤波主要是根据信号和噪声之间的统计特性差异完成滤波的。时域滤波一般基于最小二乘法 ，又称为波形估计，按照不同的功能又可以分为线性平滑、线性预测和维纳滤波。数字滤波器的数学模型

9. 线性时不变数字滤波器的数学模型有多种表示方法，在时域中可以用线性常系数差分方程：$y[n]=-\sum\limits^N_{k=1} d_ky[n-k]+\sum\limits^M_{q=0}p_qx[n-q]$,等效的$Z$域传递函数为：$H(z)=\frac{\sum\limits^M_{q=0}p_qz^{-q}}{1+\sum\limits^N_{k=1}d_kz^{-k}}$ ,当$d_k(1\le l \le N)$ 值不全为$0$时，该滤波器$Z$域系统函数至少包含一个极点，此时相应的单位脉冲必定无限长，所以该类滤波器常被称为无限冲激响应$(Inifinite\ Impulse\ Response,IIR型)$数字滤波器。对于一个稳定的数字系统 ，极点必须都在单位圆内部。

   当$d_k$值全为$0$时，$Z$域系统函数只有零点，数字滤波器的单位冲击响应有限，通常这种数字滤波器被称为有限冲激响应$(Finite\ Impulse\ Response,FIR型)$滤波器。

11. 对于$IIR$和$FIR$滤波器来讲，只有$FIR$具有线性相位，但是阻带衰减效率差；$IIR$相位特性差，但是阻带衰减效率高。有限脉冲响应$(FIR)$滤波器由有限个采样值组成，在每个采样时刻完成有限个卷积运算，可以将其幅度特性设计成多种多样，同时还可保证精确、严格的相位特性。在高阶的滤波器中，还可以通过$FFT$来计算卷积，从而极大地提高运算效率。 

12. $FIR$滤波器：$FIR$滤波器只存在$N$个抽头$h(n)$，$N$也被称为滤波器的阶数，则滤波器的输出可以通过卷积的形式表示为：$y(n) = x(n)\ast h(n) = \sum\limits^{N-1}_{i=0} h(k)x(n-k)$,$Y(z) = H(z)X(z)$,$H(z) = \sum\limits^{N-1}_{i=0} h(i)z^{-i} = \frac{h(0)z^N + h(1)z^{N-1} +\cdots+h(N-1)}{z^N}$ ,$FIR$滤波器只在原点处存在极点，这使得$FIR$滤波器具有全局稳定性。$FIR$滤波器是由一个“抽头延迟线”加法器和乘法器的集合构成，每一个乘法器的操作系数就是一个$FIR$系数.

13. $FIR$滤波器的设计方法：恒延时线性相移$FIR$滤波器的必要条件是冲激响应对中心点偶对称。若$N$为偶数，则中心点位于$(N-1)/2$和$(N/2)$之间；当$N$为奇数时，中心点位于$(N-1)/2$.

    按照$N$值奇偶和$h(n)$的奇偶对称性，可以将$FIR$滤波器分为$4$种：

    + $h(n)$为偶对称，$N$为奇数

      $H(e^{jw}) = e^{-j\frac{N-1}{2}w} \{h(\frac{N-1}{2}) +2\sum\limits^{(N-1)/2}_{n=1} h(\frac{N-1}{2}-n) cos(wn)\}$,$H(e^{jw})$的幅值关于$w=0,\pi,2\pi$成偶对称。

    + $h(n)$为偶对称，$N$为偶数

      $H(e^{jw}) = e^{-j\frac{N-1}{2}w} \sum\limits^{N/2}_{n=1} 2h(\frac{N}{2}-n) cos[(n-\frac{1}{2})w]$,$H(e^{jw})$的幅值关于$w=\pi$成奇对称，不适合做高通。

    + $h(n)$为奇对称，$N$为奇数

      $H(e^{jw})= e^{j(\frac{\pi}{2}-\frac{N-1}{2}w)} \sum\limits^{(N-1)/2}_{N=1} 2h(\frac{N-1}{2}-n) sin(nw)$ ,$H(e^{jw})$的幅值关于$w=0,\pi,2\pi$成奇对称，不适合做高通和低通。

    + $h(n)$为奇对称，$N$为偶数

      $H(e^{jw})= e^{j(\frac{\pi}{2}-\frac{N-1}{2}w)} \sum\limits^{(N-1)/2}_{N=1} 2h(\frac{N-1}{2}-n) sin[(n-\frac{1}{2})w]$ ,$H(e^{jw})$的幅值关于$w=0,\pi,2\pi$成奇对称，不适合做高通和低通.

14. 窗口法。设计线性相位$FIR$滤波器步骤：

    1. 确定数字滤波器的性能要求:临界频率$\{wc\}$,滤波器单位脉冲响应长度$N$.
    2. 根据性能要求，合理选择单位脉冲响应$h(n)$的奇偶对称性，从而确定理想频率响应$H_d(e^{j\omega})$的幅频特性和相频特性。
    3. 得到单位脉冲响应$H_d{e^{j\omega}}$后，在实际计算中，可对$H_d{e^{j\omega}}$按$M$($M$远大于$N$)点等距采样，并对其求$IDFT$得$h_m(n)$，用$h_m(n)$代替$h_d{n}$；
    4. 选择适当的窗函数$w(n)$，根据$h(n)=h_m(n)w(n)$求所需设计的$FIR$滤波器单位脉冲响应
    5. 求$H{e^{j\omega}}$,分析其幅频特性，若不满足要求，可适当改变窗函数形式或长度$N$，重复上述设计过程，以得到满意的结果

    + 常用的几种窗函数
      + 矩形窗：$w(n) = R_N(n)$
      + $Hanning$窗：$w(n)=0.5[1-cos(\frac{2\pi n}{N-1})]R_N(n)$ 
      + $Hamming$窗:$w(n) = [0.54-0.46cos(\frac{2\pi n}{N-1})]R_N(n)$ 
      + $Blackmen窗$：$w(n) = [0.42-0.5cos(\frac{2\pi n}{N-1})+0.08cos(\frac{4\pi n}{N-1})]R_N(n)$  
      + $Kaiser$窗:$w(n) = \frac{I_0(\beta\sqrt{1-[2n/(N-1)-1]^2})}{I_0(\beta)}R_N(n)$,$I_0(\beta)$为零阶贝塞尔函数。

15. 频率采样法：频率采样法是从频域出发，将给定的理想频率响应$H_d(e^{j\omega})$加以等间隔采样：$H_d(e^{j\omega})\mid_{w=\frac{2\pi}{N}k}=H_d(k)$,然后以此$H_d(k)$作为实际$FIR$数字滤波器的频率特性的采样值$H(k)$,即令$H(k)=H_d(k)$,由$H(k)$通过$IDFT$可得有限长序列$h(n)$:$h(n)=\frac{1}{N}\sum\limits^{N-1}_{k=0} H(k) e^{j\omega 2 \pi k/N}$,$n=0,1,\cdots,N-1$,代入到$Z$变换中可得:$H(z)=\frac{1-z^{-n}}{N}\sum\limits^{N-1}_{k=0}\frac{H(k)}{1-W^{-k}_{N}z^{-1}}$,$H(e^{j\omega}) = \sum\limits^{N-1}_{k=0}\phi(\omega-\frac{2\pi}{N}k)$,$\phi(\omega)$为内插函数，$\phi(\omega) = \frac{1}{N}\frac{sin(\omega N/2)}{sin(\omega/2)} e^{-j\omega(N-1)/2}$ 。看起来，频域采样法是比较简单的，但是从内插函数$\phi(\omega)$可以看到，除在每个取样点上频率响应将严格与理想特性保持一致外，在取样点之外的响应由各取样点内插得到。因此，如果取样点之间的理想特性越平缓，则内插值与理想值的误差就越大，因而在理想特性的每个不连续点附近会出现肩峰和起伏，不连续性越大，肩峰和起伏就越大。

16. 8阶的串行$FIR$低通滤波器

    ```verilog
    module FIR_Lowpass(Data_out,Data_in,clock,reset);
        parameter order = 8;
        parameter word_size_in = 8;
        parameter word_size_out = 2*word_size_in + 1;
        parameter b0 = 8'd7;
        parameter b1 = 8'd17;
        parameter b2 = 8'd32;
        parameter b3 = 8'd46;
        parameter b4 = 8'd52;
        parameter b5 = 8'd46;
        parameter b6 = 8'd32;
        parameter b7 = 8'd17;
        parameter b8 = 8'd7;
        output[word_size_out - 1 : 0 ] Data_out;
        input [word_size_in - 1 : 0] Data_in;
        input clock,reset;
        reg [word_size_in - 1 : 0] Samples[1:order];
        integer k;
        assign Data_out = b0*Data_in + b1*Samples[1] + b2*Samples[2] + b3*Samples[3] + b4*Samples[4] + b5*Samples[5] + b6*Samples[6] + b7*Samples[7] + b8*Samples[8];
        always @ (posedge clock)
            if(reset == 1) begin
                for(k=1;k<=order;k=k+1)
                    Samples[k]<=0;
            	end
        	else begin 
                Samples[1] <= Data_in;
                for(k=2;k<=order;k=k+1)
                    Samples[k] <= Samples[k-1];
            end
    endmodule
    ```


17. $IIR$系统的差分方程:$y(n) = \sum\limits^M_{l=0}a(l)x(n-l)+\sum\limits^N_{i=1}b(i)y(n-i)$,传递函数:$H(z) = \frac{\sum\limits^M_{l=0}a(l)z^{-1}}{1-\sum\limits^N_{i=1}b(i)z^{-i}}$ ,$IIR$和$FIR$滤波器相比，最大的特点是阻带衰减效率高，相位特性差。模拟滤波器设计的著名原则：全通滤波器具有单位增益，引入非零相位增益，用来实现通带内的线性化。

18. 3种常用的模拟滤波器及其数字仿真
    1. $Butterworth$滤波器性能：$Butterworth$滤波器的特点是具有通带内最大平坦的振幅特性，而且在正频率内是随频率升高而单调下降的，它的振幅平方函数为:$\mid H(\Omega)\mid ^2 = \frac1{1+c^2{\frac{\Omega}{\Omega_c}^{2N}}}$,$N$为整数，称为$Butterworth$滤波器的阶数；$\Omega_c$为通带宽度或$3dB$带宽，简称为截止频率。$Butterworth$滤波特性在通带和阻带内都是单调变化的，这种特性使得其在直流附近与理想特性有良好的近似。当频率较高时，偏离理想特性就渐大。而滤波器的阶数越高，近似就越好，但复杂度也急剧上升。
    
    2. $Chebyshev$滤波器性能：$Chebyshev$滤波器频率特性在通带内时等纹波的，在阻带内时单调下降的，它比同阶的$Butterworth$滤波器下降快。通带内波动的峰值个数与阶数$N$有关，$N$越大，波动越快。振幅平方函数为：$\mid H(\Omega)\mid^2 = \frac1{1+\epsilon^2C_N^2(\frac{\Omega}{\Omega_c})}$,$N$为滤波器的阶数；$\Omega_c$为通带宽度，当$\epsilon =1$时，它等于通带的$3dB$截止频率；$C_N()$是$Chebyshev$多项式，$C_N(x)$的定义为：$C_N(x)=cos[Ncos^{-1}x],|x|<1$,$C_N(x)=cosh[Ncosh^{-1}x],|x|>1$.可以证明，在$0\leq x\leq 1$范围内，$C^2_N(x)$在0与1之间变化着，而在$x>1$的范围内，$C_N(x)$单调地增加，$N$越大增长越快，且比任何同阶的多项式增长得都快。
    
    3. 椭圆滤波器:通带和阻带内都有等纹波的振幅特性。它之所以被称为椭圆滤波器是因为振幅特性是由雅可比椭圆函数来决定的，其振幅平方函数为$\mid H(\Omega)\mid^2 = \frac{1}{1+\epsilon^2J^2_N(\Omega)}$,$J^2_N(\Omega)$为雅可比椭圆函数，$N$为滤波器的阶数。
    
    4. 一个良好的滤波器结构应当考虑到以下几个方面
       + 使用尽量少的存储单元
       + 系数对零极点敏感度低，以减少字长效应的影响
       + 计算量小，稳定性好，运算精度高
       + 尽可能地具备并行运算能力，以便FPGA芯片快速实现 
    
    19. ```verilog
        //verilog实现一个8阶的IIR滤波器
        module IIR_Filter_8(Data_out,Data_in,clock,reset);
            parameter order = 8;
            parameter word_size_in = 8;
            parameter word_size_out = 2*word_size_in+2;
            parameter b0 = 4;	//前馈滤波器系数
            parameter b1 = 22;
            parameter b2 = 65;
            parameter b3 = 110;
            parameter b4 = 110;
            parameter b5 = 65;
            parameter b6 = 22;
            parameter b7 = 8;
            
            parameter a1 = 25;      //反馈滤波器系数
            parameter a2 = -70;
            parameter a3 = 99;
            parameter a4 = -85;
            parameter a5 = 47;
            parameter a6 = -16;
            parameter a7 = 4;
            parameter a8 = 1;
            output[word_size_out - 1 : 0] Data_out;
            input [word_size_in - 1 : 0]  Data_in;
            input clock,reset;
            reg[word_size_in-1:0] Samples_in[1:order];
            reg[word_size_in-1:0] Samples_out[1:order];
            wire [word_size_out-1:0] Data_feedforward;
            wire [word_size_out-1：0] Data_feedback;
            integer k;
            
            assign Data_feedforward = b0*Data_in + b1*Samples_in[1] + b2*Samples_in[2] + b3*Samples_in[3] + b4*Samples_in[4] + b5*Samples_in[5] + b6*Samples_in[6] +b7*Samples_in[7];
            assign Data_feedback = a1*Samples_out[1] + a2*Samples_out[2] + a3*Samples_out[4] + a5*Samples_out[5] + a6*Samples_out[6] + a7*Samples_out[7] + a8*Samples_out[8];
            assign Data_out = Data_feedforward + Data_feedback;
            
            always @ (posedge clock)
                if(reset == 1)
                    for(k=1;k<=order;k=k+1) begin
                        Samples_in[k] <= 0;
                        Samples_out[k] <=0;
                    end
            	 else begin
                     Samples_in[1] <= Data_in;
                     Samples_out[1] <= Data_out;
                     for(k=2;k<=order;k=k+1) begin
                         Samples_in[k] <= Samples_in[k-1];
                         Samples_out[k] <= Samples_out[k-1];
                     end
                 end
        endmodule    
        ```
    
        上述滤波器采用并行操作，只需要两个时钟周期，就可以得到滤波结果，但由于同时对多个乘累加器进行操作，工作频率不能太高，同样，采用加寄存器的方法来提高IIR滤波器的工作频率，
    
        级联型是一种较为容易实现的高效方式，其主要思想是将系统函数$H(z)$的分子、分母多项式分解为二阶子系统的乘积形式。$H(z) = \prod\limits^K_{k=1}H_k(z)$,其中，每一级的二姐子系统的传输函数形式为：$H_k(z) = \frac{1+\alpha_{1i}z^{-1}+\alpha_{2i}z^{-2}}{1+\beta_{1i}z^{-1}+\beta_{2i}z^{-2}}$  
    
        ```verilog
        //verilog实现一个2阶的级联型IIR滤波器
        module iir_c(clk,reset,x_in,y_out);
            input clk;
            input reset;
            input [15:0] x_in;
            output [15:0] y_pit;
            wire [15:0] y1_out;
            wire [15:0] a1_1_1,a1_2_1,b1_1_1,b1_2_1;
            wire [15:0] a2_1_1,a2_2_1,b2_1_1,b2_2_1;
            
            assign a1_1_1 = 36504;
            assign a1_2_1 = -23396;
            assign b1_1_1 = 0;
            assign b1_2_1 = 32768;
            assign a2_1_1 = 0;
            assign a2_2_1 = 58832;
            assign b2_1_1 = 32768;
            assign b2_2_1 = 36054;
            sub2 sub2_1(.clk(clk), .reset(reset), .a_1_1(a1_1_1), a_2_1(a1_2_1), .b_1_1(b1_1_1), .b_2_1(b1_2_1), x_in(x_in), .y_out(y1_out));
            sub2 sub2_1(.clk(clk), .reset(reset), .a_1_1(a2_1_1), a_2_1(a2_2_1), .b_1_1(b2_1_1), .b_2_1(b2_2_1), x_in(x_in), .y_out(y1_out));
        endmodule
        //=======================================
        mdoule sub2(clk,reset,a_1_1,a_2_1,b_1_1,b_2_1,x_in,y_out);
        input clk;
        input reset;
        input [15:0] a_1_1;
        input [15:0] a_2_1;
        input [15:0] b_1_1;
        input [15:0] b_2_1;
        input [15:0] x_in;
        output [15:0] y_out;
        reg [47:0] x_temp;
        reg [47:0] y_temp;
        wire [31:0] x_t;
        wire [31:0] y_t;
        
        always@(posedge clk ) begin 
            if(!reset) begin
                x_temp <= 0;
                y_temp <= 0;
            end 
           	else begin
                x_temp[47:0] <= {x_temp[31:0],x_in};
                y_temp[47:0] <= {y_temp[31:0],x_t[31:16]};
            end
        end 
        assign x_t = reset?x_temp[47:32]*a_2_1+x_temp[31:16]*b_1_1+x_temp[15:0]:0;
        assign y_t = reset?y_temp[47:32]*b_2_1+y_temp[31:16]*b_1_1+y_temp[15:0]:0;
        assign y_out[15:0] = y_t[31:16];
        endmodule
        ```
    
19. 脉冲成型滤波器：矩形脉冲通过限带信道时，脉冲信号会在时间上扩展。每个符号的脉冲将扩展到相邻信号的码元内，造成码间干扰，并导致接收机在检测码元时发生错误的概率增大。一种常用的方法是增大宽带，但由于带宽在数字移动通信系统中是非常宝贵和紧缺的资源，所以需要一种技术能够在减少码间干扰影响的同时，还能够减少调制带宽和抑制频带外的扩散，提高信号频谱的利用率。
    1. 在数字通信中，基带信号的频谱范围很宽，为了有效地利用信道，在信号传输出去之前都要对信号频谱压缩，使其在消除码间干扰和达到最佳检测的前提下，大大提高频带的利用率。利用脉冲成型滤波器对信号进行滤波，就能有效地达到这一功能。在数字信号传输过程中，只要求特定时刻的波形幅值如何无失真地传送，而不必要求整个波形无失真。奈奎斯特第一准则告诉我们：如果信号经传输后整个波形发生了变化，但只要其特定点地抽样值保持不变，那么用再次抽样的方法，仍然可以准确无误地恢复原始信码。
    2. 满足奈奎斯特第一准则的滤波器有很多种，在无线通信中得到广泛应用的是其幅度频率响应具有奇对称升余弦形状过渡带的一类滤波器，通常称为升余弦滚降滤波器。升余弦滤波器本身是一种有限脉冲响应$(FIR)$滤波器，其传递函数的表达式为：$X_{RC}(F) = \begin{cases} T_s,\qquad \qquad 0\le|f|\le\frac{1-\alpha}{2T_s} \\ \frac{T_s}{2}\{1+cos[\frac{\pi T_s}{\alpha}(|f|-\frac{1-\alpha}{2T_s})]\},\qquad \frac{1-\alpha}{2T_s} \le|f|\le\frac{1+\alpha}{2T_s} \\0, \qquad \qquad |f|>\frac{1+\alpha}{2T_s} \end{cases}$   ,其中，$\alpha$为滚降因子，取值为：$0\le\alpha\le1$.在$\alpha = 0$时，滤波器的带宽$W$为$1/(2T_s)$，称为奈奎斯特带宽；$\alpha = 0.5$时，滤波器的截止频率$W$为$(1+\alpha)/(2T_s) = (1+0.5)/(2T_s)$，等于$0.75R_s$;$\alpha=1$，滤波器的截止频率$W$为$(1+1)/(2T_s)=R_s$。

20. 多速率滤波器有多速率FIR滤波器、积分级联梳状(CIC)滤波器和半带(HB)滤波器等。多速率滤波器的主要作用有三点：抽取（即降低信号速率）、插值（即提高信号速率）和低通滤波。

    ```VERILOG
    //Verilog实现输入信号的4倍插值
    module decimate_4(clk,reset,x,y)
        input clk;
        input reset;
        input [7:0] x;
        output [7:0] y;
        reg [1:0] cnt;
        reg [7:0] y;
        always@(posedge clk) begin
            if(!reset)
                cnt <= 0;
            else begin
                cnt <= cnt  + 1;
                if(cnt == 0)
                    y<=x;
                else 
                    y <=0;
            end
        end
    endmodule
    ```

21. 信号多项分解的FPGA实现:用Verilog实现一个4阶的多项抽取滤波器，实现2倍下采样，其多相传递函数为$G(z)=(124+57z^{-2})/256+z^{-1}(214-33z^{-2})$ 

    ```verilog
    module polyfilter(clk,clk2,reset,x_in,y_out);
        parameter even=0,odd=1;
        input clk;		//输入信号的速率
        input clk2;		//输入信号的速率的一半
        input reset;
        input [7:0] x_in;	//输入信号
        output [8:0] y_out; 	//输出信号
        //各个中间寄存器，包括系数及乘法器的输入参数
        reg [16:0] m0,m1,m2,m3,r0,r1,r2,r3;
        reg [16:0] x33,x99,x107;
        reg [16:0] y;
        reg [7:0] x_odd,x_even,x_wait; //多相分解后的奇偶信号
        wire [16:0] x_odd_sxt,s_even_sxt;
        reg state;
        always@(posedge clk) begin
            if(!reset) begin
                state <= even;
                x_even <= 0;
                x_odd <= 0;
            end
            else begin
                case(state) //奇偶序列分开
                    even:begin
                        x_even <= x_in;
                        x_odd <= x_wait;
                        state <= odd;
                    end
                    odd:begin
                        x_wait <= x_in;
                        state <= even;
                    end
                endcase
            end
        end 
        assign x_odd_sxt <= {{9{x_odd[7]}},x_odd};
        assign x_even_sxt <= {{9{x_even[7]}},x_even};
        
        always@(posedge clk) begin
            if(!reset) begin
                x33 =0;
                x99 =0;
                x107 =0;
                m0 = 0;
                m1 = 0;
                m2 = 0;
                m3 = 0;
            end 
            else begin
                x33 = (x_odd_sxt <<5 )+s_odd_sxt;
                x99 = (x33 <<1)+x33;
                m0 = (x_even_sxt <<7)-(x_even_sxt<<2);//m0 = 124;
                m1 = x107<<1;
                m2 = (x_even_sxt <<6)-(x_even_sxt<<3)+x_even_sxt;
                m3 = x33;
            end 
        end
        always@(negedge clk2) begin
            if(!reset) begin
                r0 <= 0;
                r2 <= 0;
                r1 <= 0;
                r3 <= 0;
            end 
            else begin
                r0 <= r2+m0;
                r2 <= m2;
                r1 <= -r3 + m1;
                r3 <= m3;
                y <= r0+r1;
            end
        end
        assign y_out = y[16:8];
    endmodule
    ```

    22. CIC滤波器：在数字信号处理中，随着采用频率的提高，采用后的数据流速率变得很高，这会导致后序的信号处理速度跟不上，因此有必要对A/D后的数据流进行降速处理。多速率信号处理技术为这种降速处理的实现提供了理论依据。实现取样速率变换（抽取和内插）的关键问题是如何实现抽取前或内插后的数字滤波。无论是抽取还是内插，或者是取样率的分数倍变换，都需要设计一个满足抽取或内插(扛混叠)要求的数字滤波器。该滤波器性能的好坏直接影响取样速率变换的效果及实时处理能力。在这方面，积分级联梳状(CIC)滤波器和半带(HB)滤波器具有比较好的性能。CIC滤波器是无线通信中的常用模块，一般用于数字下变频(DDC)和数字上变频(DUC)系统。CIC滤波器的结构简单，没有乘法器，只有加法器、积分器和寄存器，适合工作在高采样率。CIC滤波器是一种基于零极点相消的FIR滤波器，已经被证明是在高速抽取或插值系统中非常有效的单元。CIC滤波器包括两个基本组成部分：积分器和梳状部分。
    
        ```verilog
        //单级抽取CIC滤波器的Verilog实现。单级、抽取率为2的8位CIC抽取滤波器，系统工作时的频率和数据速率相等
        module cic_dec_2_simgle(clk,clk1,reset,x_in,y_out)
            input clk; //系统工作时钟
            input clk1;//系统工作时钟的一半
            input reset //系统控制信号
            input [7:0] x_in;//单级CIC滤波器输入信号
            output [7:0] y_out;//单级CIC滤波器输出信号
            reg [15:0] x_t,y_t; //用于移位的寄存器
            reg [7:0] int_out; //积分滤波器部分的输出
            always@(posedge clk) begin
                if(!reset) begin
                    x_t <= 0;
                    int_out <= 0;
                end
                else begin
                    x_t <={x_t[7:0],x_in[7:0]};
                end
                int_out <= x_t[7:0]+x_t[15:8]; //完成单级积分滤波
            end
            always@(posedge clk1) begin //完成抽取，因为clk1是clk的一半
                if(!reset) begin
                    y_t <=0;
                end
                else begin
                    y_t <={y_t[7:0],int_out[7:0]};
                end
            end
            //完成单级梳状滤波
            assign y_out=y_t[7:0]-y_t[15:8];
        endmodule
        //多级抽取CIC滤波器的Verilog实现：一个3级、抽取率为2的8位Hogenauer CIC抽取滤波器，系统工作时钟的频率和数据速率相等
        module cic_dec_8_three(clk,clk1,reset,x_in,y_out)
            input clk; //系统工作时钟
            input clk1;
            input reset; //系统控制信号
            input [7:0] x_in; //3级CIC滤波器输入信号
            output [7:0] y_out; //3级CIC滤波器输出信号
            reg [7:0] y_out; //将输出设置成寄存器行
            reg [15:0] i1,i2,i3,c1,c2,c3; //用于移位的寄存器
            reg [7:0] int_out1,int_out2,int_out3,comb_out1,comb_out2;
            //3级积分滤波器的级联
            always@(posedge clk) begin
                if(!reset) begin
                    i1 <= 0; i2 <= 0; i3 <= 0; int_out1 <= 0;int_out2 <= 0;int_out3 <= 0;
                end
                else 
                    i1 <= {i1[7:0],x_in};
                i2 <= {i2[7:0],int_out1};
                i3 <= {i3[7:0],int_out2};
                int_out1 <= i1[7:0]+i1[15:8];
                int_out2 <= i2[7:0]+i2[15:8];
                int_out3 <= i3[7:0]+i3[15:8];
            end
            //3级梳状滤波器的级联
            always@(posedge clk) begin
                 if(!reset) begin
                     c1 <= 0; c2 <= 0; c3 <=0; comb_out1 <=0;comb_out2<=0;y_out <= 0;
                 end
                else begin
                    c1 <= {c1[7:0],int_out3};
                    c2 <= {c2[7:0],comb_out1);
                    c3 <= {c3[7:0],comb_out2};
                   comb_out1 <= c1[7:0]-c1[15:8];
                   comb_out2 <= c2[7:0]-c2[15:8];
                   y_out <= c3[7:0]-c3[15:8];
                   end
               end
        endmodule     
        //单级插值CIC滤波器，单级、过采样为2的8位CIC插值滤波器，系统工作时钟的频率是数据速率的2倍
        module cic_interp_2_signle(clk,clk1,reset,x,y)
            input clk;   //模块工作时钟
            input clk1;   //其数值为clk的一半
            input reset;  
            input [7:0] x;
            output [7:0] y;
            reg [15:0] x_t,y_t;  //用于移位的寄存器
            reg [7:0] ubt_out,temp; //中间变量
            always@(posedge clk1) begin
                if(!reset) begin
                    x_t <= 0;
                    int_out <= 0;
                end
                else begin
                    x_t <= {x_t[7:0],x};
                    int_out <= x_t[7:0]+x_t[15:8];
                end
            end 
            always@(posedge clk) begin
                if(!reset) begin
                    y_t <= 0;
                    temp <=0;
                end
                else begin
                    if(clk1 == 1)    //完成插值
                        temp <= 0;
                    else 
                        temp <=int_out;
                    	y_t <= {y_t[7:0],temp};
                end
            end
            assign y_t[7:0] - y_t[15:8];
        endmodule
        //多级插值CIC滤波器的verilog实现：单级、过采样为2的8位CIC插值滤波器，系统工作时钟的频率是数据速率的2倍
        module cic_interp_8_three(clk,clk1,reset,x_in,y_out);
            input clk;
            input clk1;
            input reset;
            input [7:0] x_in;
            output [7:0] y_out;
            reg [7:0] y_out;
            reg [15:0] i1,i2,i3,c1,c2,c3;
            reg[7:0] int_out1,int_out2,int_out3;
            reg [7:0] comb_out1,comb_out2,temp;
            always@(posedge clk1) begin
                if(!reset) begin
                    i1 <= 0; i2 <= 0; i3 <= 0; int_out1 <= 0;int_out2 <= 0;int_out3 <= 0;
                end
                else begin
                     i1 <= {i1[7:0],x_in};
                    i2 <= {i1[7:0],int_out1};
                    i3 <= {i1[7:0],int_out2};
                    int_out1 <= i1[7:0]+i1[15:8];
                	int_out2 <= i2[7:0]+i2[15:8];
                	int_out3 <= i3[7:0]+i3[15:8];
                end
            end
            always@(posedge clk) begin
                if(!reset) begin
                    temp <= 0; c1 <= 0; c2 <= 0; c3 <=0;comb_out1 <=0;comb_out2 <=0;
                end
                else begin
                    if(clk1==1)
                        temp <=0;
                    else 
                        temp <= int_out3;
                    c1 <= {c1[7:0],temp};
                    c2 <= {c1[7:0],comb_out1};
                    c3 <= {c1[7:0],comb_out2};
                    comb_out1 <= c1[7:0]-c1[15:8];
                    comb_out2 <= c2[7:0]-c2[15:8];
                    y_out <= c3[7:0]-c3[15:8];
                end
            end
        endmodule
        ```

23. FIR半带滤波器：可以将离散系统的工作频率范围分成对等的两个对称部分，且运算复杂度低，在多速率信号处理中有着重要的地位。由于FIR半带滤波器能够提供比IIR半带滤波器更精确的线性相位，而线性相位对通信信号处理是至关重要的，
    + 由于半带滤波器是偶对称、奇次的线性相位FIR滤波器，因而还具有以下三个性质：第一，滤波器的阶数N为奇数；第二，滤波器的冲击响应$h(n)$为实数；第三，滤波器的幅度函数$H(w)$为偶函数。

24. 数字调制与解调
    + 从信号空间的角度看，调制实际上是把信号从信道编码后的汉明空间映射成调制后的欧式空间。
    + 调制的功能主要有频谱搬移、抗干扰、提供频谱利用率，以及改变信号的峰均比
    + 调制的三种形式：振幅键控、移频键控、移相键控，即分别使用基带信号来控制调制信号的幅度、频率和相位。    
    + 线性调制是指已调波中被调参数随调制信号成线性变化的调制过程。此外，在二进制基带调制中，为了彻底消除由于相位跃变带来的峰均比增加和频带扩展问题，又引入了有记忆的非线性连续相位调制CPM、最小频移键控MSK、GMSK及平滑调频TFM等。GSM系统的恒包络调制GMSK，CDMA系统中的BPSK和QPSK

 1. 欧式距离：通过将二进制的已调信号矢量表达为二维欧氏空间的距离，可以分析信号的抗干扰能力。显然最小欧氏距离越大，抗干扰能力越强

    + 2-ASK调制：当基带信号为0时，不发送载波。当基带信号为1时，发送归一化载波。

    + 2-FSK调制：当基带信号为0时，发送频率为$f_0$的载波；当基带信号为1时，发送频率为$f_1$的载波。因为需要保证频率为$f_0$与$f_1$的信号互不干扰，所以二者应当正交。

    + 2-PSK调制：当基带信号为0时，发送归一化幅度且相位为$\phi _0=0$的载波；当基带信号为1时，发送归一化幅度且相位为$\phi_1=\pi$的载波。

    + 2-ASK、2-FSK、2-PSK的欧氏距离分别为1、$\sqrt2$和2。因此，2-PSK的性能优于2-FSK，2-FSK的性能优于2-ASK.

    + 采用相干解调时，各种调制方式的误比特率公式为：$2-ASK:\qquad P_b=\frac12erfc(\sqrt\frac{E_b}{4N_0})=Q(\sqrt\frac{E_b}{2N_0})$ 

      $2-FSK: \qquad P_b=\frac12erfc(\sqrt\frac{E_b}{2N_0})=Q(\sqrt\frac{E_b}{N_0})$ 

      $2-PSK：\qquad P_b=\frac12erfc(\sqrt\frac{E_b}{N_0})=Q(\sqrt\frac{2E_b}{N_0})$   

      由于$Q(\cdot)$是减函数，同样可以得到$2-PSK$性能最佳的结论

    + 信号功率谱密度(PSD)定义：$P_x(f)=\lim\limits_{T\rightarrow+\infty}(\frac{E[|X_T(f)|^2]}{T})$ ,$X_T(f)$为$x(t)$的傅里叶变换。

    2. 香农第二定律：在加性高斯白噪声环境中，在任意小的错误概率下，带宽效率$\eta$受制于信噪比$\eta \le \frac{R_b}{B}=log_2(1+SNR)$ ,$R_b$为二进制比特速率，$B$为有效带宽，$SNR$为信噪比。
    
    3. $2-ASK$调制：又称为二进制启闭键控(OOK,On-Off Keying),它是以单极性不归零码来控制载波的开启和关闭的，其调制方法出现的比模拟调制还早。虽然$2-ASK$的抗干扰性能不如其他调制方式，在无线通信中未得到实际应用，在光纤通信中广泛应用。
    
       ![2-ask.png](https://s2.loli.net/2022/03/08/GYXVyn3K6pC9Suk.png)
    
    4. $2-ASK$解调及误比特率：有两种方式：一种是相干解调；另一种是包络检波的非相干解调。相干解调器的性能相对较好，而非相干解调和相干解调存在着3dB的性能差异。
    
       + 相干解调器也称为同步解调，一般定义为利用与接收信号同频同相的恢复载波来进行的解调。其原理是：首先从接收信号中提取离散的载波分量，使得所恢复的频率及相位与接收的信号同频同相，然后再将恢复载波与接收信号相乘，经过低通滤波器后消除二倍频分量，最后再对信号经过采样、判决，即可恢复出所发送的数据信号。
       + 非相干解调器：利用包络检波，原理简单。输入->包络检波器->采样->判决->输出
    
     ```verilog
     //verilog 实现2-ASK调制
     module two_ASK(clk,reset,x,y)
         input clk; //模块工作时钟
         input reset;//模块控制信号
         input x; //输入信号
         output y; //调制输出信号
         //cnt是分频计数器
         reg[1:0] cnt;
         //carriers是要调制的载波信号，将输入信号clk经过4分频得到
         reg carries;
         always@(posedge clk) begin
             if(!reset) begin
                 cnt <= 2'b00;
                 carriers <= 0;
             end
             else begin
                 if(cnt == 2'b11) begin
                     cnt <= 2'b00;
                     carriers <= ~carriers;
                 end
                 else  begin
                     carriers <= carriers ;
                     cnt <= cnt + 1;
                 end 
             end
         end
         assign y = x & carriers;
     endmodule
     //verilog实现2-ASK解调
     module ASK_two(clk,reset,x,y)
         input clk;
         input reset;
         input x;
         output y;
         reg y;
         reg[2:0] cnt;
         reg[2:0] m;
         always@(posedge clk) begin
             if(!reset) begin
                 cnt <= 3'b000;
             end
             else if(cnt == 3'b111)
                 cnt <= 3'b000;
             else cnt <= cnt +1;
         end
         always@(posedge x) begin
             if(!reset) begin
                 m <= 3'b000;
             end
             else begin
                 if(cnt == 3'b110) begin
                     if(m <= 3'b010)
                         y <= 1'b0;
                     else 
                         y <= 1'b1;
                     m <=3'b000;
                 end
                 else 
                     m <= m+1;
             end 
         end
     endmodule
     ```
    
    5. $2-PSK$：输出信号形式为：$s(t)=\begin{cases} \quad Acos(W_c+\phi_1), \qquad b_n=1 \\ -Acos(W_c+\phi_2), \qquad b_n = -1 \end{cases}$  $nT_b \le t \le (n+1)T_b$ ![2-psk.png](https://s2.loli.net/2022/03/08/xkaqGFg79Zbp6Lr.png)
    
    6. QPSK调制原理：四进制移相键控信号的正弦波载波有4个可能的离散相位状态，每个载波相位携带2个二进制符号，其信号表达式为$s(t)=Acos(W_ct+\theta_i) \qquad i=1,2,3,4,0\le t \le T_s$,$T_s$为四进制符号间隔，$\{\theta_i：i=1,2,3,4\}$为正弦波载波的相位，有4种可能状态，可以取值为$\theta_i=(i-1)\pi/2$或$\theta_i=(2i-1)\pi/4$.
    
       QSPK调制信号说明
    
       | 输入信号 | 载波相位 | 载波波形                                         |
       | -------- | -------- | ------------------------------------------------ |
       | 00       | 0        | $\overline{}\overline{}\underline{}\underline{}$ |
       | 01       | $\pi/2$  | $\overline{}\underline{}\underline{}\overline{}$ |
       | 10       | $\pi$    | $\underline{}\underline{}\overline{}\overline{}$ |
       | 11       | $3\pi/2$ | $\underline{}\overline{}\overline{}\underline{}$ |
    
       ```verilog
       //假设clk信号的频率是输入信号x频率的4倍
       module QPSK(clk,reset,x,y)
           input clk; //系统工作时钟
           input reset; //系统控制信号
           input x;      //系统输入信号
           output y;     //QPSK调制输出信号
           reg [2:0] cnt ; // 计数器
           reg [1:0] x_x; //输入信号的中间寄存器
           reg [3:0] carriers; //4路载波信号
           reg [1:0] y_y;
           
           always@(posedge clk) begin
               if(!reset)
                   cnt <= 3'b000;
               else 
                   cnt <= cnt +1;
           end
           always@(posedge clk) begin
               if(!reset)
                   x_x <= 2'b00;
               else 
                   if(cnt[1:0]==2'b11)
                       x_x <= {x_x[0],x};
               	else 
                       x_x <= x_x;
           end
           always@(posedge clk ) begin
               if(!reset)
                   carriers <= 4'b000;
               else begin
                   case(begin)
                       3'b000:begin
                           y_y <= x_x;
                           carriers <= 4'b1100;
                       end
                       3'b010:carriers <= 4'b1001;
                       3'b100:carriers <= 4'b0011;
                       3'b110:carriers <= 4'b0110;
                       default:carriers <=carriers;
                       endcase
                   end
               end
       end 
               assign y=(y_y == 2'b00)?carriers[3]:
                            (y_y == 2'b01)?carriers[2]:
                            (y_y == 2'b10)?carriers[1]:
                            (y_y == 2'b11)?carriers[0]:0;
       endmodule
       ```
    
       ```verilog
       module QPSK_two(clk,reset,x,y);
           input clk;
           input reset;
           input x;
           output y;
           reg[7:0] temp;
           reg[7:0] temp2;
           reg[2:0] cnt;
           wire[1:0] y1;
           always@(posedge clk) begin
               if(!reset)
                   cnt <= 3'b111;
               else begin
                   cnt <= cnt +1;
                   if(cnt==3'b111)
                       temp <= temp2;
                   else 
                       temp <= temp;
                   temp2 <= {temp2[6:0],x};
               end
           end
           assign y1=(reset==0)?2'b00:
               (temp==8'b11110000)?2'b00:
               (temp==8'b11000011)?2'b01:
               (temp==8'b00001111)?2'b10:
               (temp==8'b00111100)?2'b11:2'b00;
           assign y=(cnt[2]==0)?y[1]:y1[0];
       endmodule
       ```
    
    7. 恒包络连续相位调制方式，如最小频移键控(MSK)和高斯最小频移键控(GMSK).GMSK是一种特殊的FSK，是MSK的进一步优化。GSM系统就采样了GMSK调制。
    
       + $2-FSK$调制解调原理。设输入到调制器的双极性比特流为$\{b_n\},n\in (-\infty,\infty).$$FSK$的输出信号形式为：$s(t)= \begin{cases} s_1(t) = cos(2\pi f_1t+\phi_1), \qquad b_n=1 \\s_2(t)=cos(2\pi f_2t+\phi_2), \qquad b_n=-1  \end{cases}$ ,即当输入符号为“1”时，输出频率为$f_1$的载波；当输入符号位“-1”时，输出频率为$f_2$的载波。![2-FSK.png](https://s2.loli.net/2022/03/08/5OEDkauQNxoZn4s.png) 
    
       + $MSK$调制解调原理：当连续相位2-FSK两信号正交时的频率间隔为$1/(2T_b)$，即为MSK时，MSK是一种特殊形式的FSK，具有最小移频键控。定义其调制指数为：$h=\frac{2\Delta f}{1/T_b}=0.5$,$T_b$为输入数据流的比特宽度。因此MSK时连续相位移频键控的特例，当$h=0.5$时，满足在码元交替点相位连续的条件，是FSK为保证良好的误码性能所允许的最小调制指数，且此时波形是正交的。因此，在限带系统中，能够保持恒包络特性。MSK信号的表达式为：$X(t)=Acos(b_k\frac{\pi t}{2T_b}+\phi_k)cosw_ct-Asin(b_k\frac{\pi t}{2T_b}+\phi_k)sinw_kt$,$b_k$为信息位，$b_k=\pm 1$;$\phi_k$为积分常数。![msk.png](https://s2.loli.net/2022/03/08/OBUc5iMWoeDQTF1.png) 
    
       + GMSK调制解调原理：尽管MSK信号已具有较好的频谱和误码率性能，但仍不能满足无线通信从邻道辐射低于主瓣达到60dB以上的要求。可将数字基带信号先经过一个高斯滤波器整形(预滤波)，由于成型后的高斯脉冲包络无陡峭边沿，亦无拐点，于是经调制后的已调频率相位路径在MSK基础上获得平滑，这被称为GMSK调制。高斯低通滤波器也称为预调制滤波器，假设其3dB带宽为$B_b$，其冲激响应为：$h(t)=\sqrt\pi\cdot\sqrt\frac{2}{ln2}B_bexp(-\pi^2a^2t^2)$.GMSK信号的表达式为：$s(t)=cos\{w_ct+\frac{\pi}{2T_b} \int^t_{-\infty}[\sum b_ig(\tau-iT-\frac{T_b}{2})]d\tau\}$ 
    
         ```verilog
         //verilog实现频率选择法的2-fsk调制，要求输入信号频率为1khz，输入信号为1时，调制器输出信号是频率为2.5khz，否则输出频率为5khz的方波，系统时钟为20khz
         module two_fsk(clk,reset,x,y);
             input clk;
             input reset;
             input x;
             output y;
             reg [2:0] cnt1;
             reg [1:0] cnt2;
             reg f1;
             reg f2;
             always@(posedge clk) begin  //2.5khz
                 if(!reset) begin
                     cnt1 <= 3'b000;
                     f1<=0;
                 end
                 else 
                     if(cnt1==3'b111)
                         cnt1<=3'b000;
                 else 
                     cnt1 <= cnt1+1;
                 f1<=cnt1[2];
             end
             always@(posedge clk) begin
                 if(!reset) begin
                     cnt2 <= 2'b00;
                     f2 <=0;
                 end
                 else 
                     if(cnt2==2'b11)
                         cnt2<=2'b00;
                 else 
                     cnt2<=cnt2+1;
                 f2<=cnt2[1];
             end
             assign y=(reset==0)?0:(x==1)?f1:f2;
         endmodule
         //对于解调
         module fsk_two(clk,reset,x,y);
             input clk;
             input reset;
             input x;
             output y;
             reg y;
             reg [4:0] cnt;
             reg [2:0] cnt1;
             always@(posedge clk) begin
                 if(!reset)
                     cnt <=5'b00000;
                 else 
                     if(cnt==5'b10011)
                         cnt <=5'b00000;
                 	else
                         cnt <= cnt + 1;
             end
             
             always@(posedge clk or posedge x) begin
                 if(!reset)
                     cnt1 <= 3'b000;
                 else 
                     if(cnt==5'b00000) begin
                         if(cnt1>4)
                             y<=0;
                         else 
                             y<=1;
                         cnt1<=3'b000;
                     end
                 else
                     cnt1<=cnt1+1;
             end
         endmodule
         //另一实例 p292
       + QAM:正交幅度调制是由两个正交载波的多电平振幅键控信号叠加而成的，在同样的符号速率下能够提供更高的比特传输速率，而不影响传输的可靠性。

25. OFDM 正交频分复用：OFDM技术使用多载波调制技术，各个子载波互相正交，且各个子载波的频谱有1/2的重叠。每个OFDM符号是多个经过调制的子载波信号之和。如果用N表示子信道的个数，T表示OFDM符号的宽度，$d_i(0,1,\cdots,N-1)$是分配给每个子信道的数据符号，$f_c$是载波频率，则从$t=t_s$开始的OFDM符号可以表示为:$s(t)=Re\{\sum\limits^{N/2}_{i=-N/2} d_{i+N/2}exp[j2\pi(f_c-\frac{i+0.5}{T})(t-t_s)], \quad t_s\le t\le t_s+T \}$ 。接收端第k路子载波信号的解调过程为：将接收信号与第k路的解调信号载波$exp(-j2\pi t(k-N/2)/T)$相乘，然后将得到的结果在OFDM符号内的持续时间T内进行积分，即可获得相应的发送信号$\hat{d_k}$，即$\hat{d_k} = \frac1T \sum\limits^{N/2}_{i=-N/2} d_{i+N/2} \int^{t_s+T}_{t_s}exp(-j2\pi\frac{i-k+N/2}{T}(t-t_s))d_t = d_k$ .

26. 有噪信道编码定理：即香浓第二定理：在有噪信道中，当信息传输速率小于信道容量是，就存在一种编码、解码方法，能够使译码的错误概率任意小。

27. 信道编码的基本思想是将每K个连续的信息比特分成一组，经过适当的数学运算(编码)后得到n个比特的输出，这n个比特组成的序列就称为一个码字。定义$R=\frac kn$为编码速率，简称码率。那么经过信道编码后的码元速率为$R_c=R_bn/k$,其中$R_b$为信息传输速率。乘积码、代数几何码、分组码、卷积码、Turbo码和低密度校验码(LDPC)等编码方法，序列译码、Viterbi译码、软判决译码和迭代译码等译码方法，以及编码与调制相结合的TCM技术。其中，GSM系统采样约束长度为5、码率为1/2的卷积码，大多数太空检测器也采样卷积码；在IS-95系统中，上行链路采用约束长度为9、码率为1/3的卷积码，下行链路采用约束长度为9、码率为1/2的卷积码；Turbo码已在3G移动通信中被采用，在BPSK调制方式下性能距Shannon极限仅有0.1dB的差距；LDPC码在BPSK调制方式下的性能距Shannon极限仅有0.07dB。

    功能上分为3类：

    + 仅具有发现差错功能的检错码，如循环冗余校验(CRC)码、自动请求重传(ARQ)等；
    + 具有自动纠错功能的纠错码，如循环码中的BCH码、RS码以及卷积码、级联码、Turbo码
    + 既有检错功能又有纠错功能的信道编码。最典型的是混合ARQ，又称为HARQ

​	从结构和规律上分为两类：线性码（大部分实用化的信道编码均属于线性码）；非线性码 

```verilog
module crc_16(clk,reset,x,crc_reg,crc_s);
    input clk;
    input reset;
    input x;
    output [15:0] crc_reg;
    output crc_s;
    reg[15:0] crc_reg;
    reg crc_s;
    reg[3:0] cnt;
    wire[15:0] crc_enc;
    always@(posedge clk) begin
        if(!reset) begin
            crc_reg<=0;
            cnt<=0;
        end
        else  begin
            crc_reg <= crc_enc;
            cnt <= cnt +1;
            if(cnt==0)
                crc_s<=0;
            else 
                crc_s<=1;
        end
    end
    assign crc_enc[0]=crc_reg[15]^x;
    assign crc_enc[1]=crc_reg[0];
    assign crc_enc[2]=crc_reg[1]^crc_reg[15]^x;
    assign crc_enc[14:3]=crc_reg[13:2];
    assign crc_enc[15]=crc_reg[14]^crc_reg[15]^x;
endmodule
```

```verilog
//verilog实现一个(2,1,2)卷积码编码器
module conv_enc(clk,reset,x,y);
    input clk;
    input reset;
    input x;
    output y;
    reg y;
    parameter s0=2'b00,s1=2'b01,s2=2'b10,s3=2'b11;
    reg clk1;
    reg [1:0] state,next_state;
    reg [1:0] enc_out;
    always@(posedge clk) begin
        if(!reset) begin
            state <= s0;
            clk1 <= 0;
            next_state <= s0;
            enc_out <=2'b00;
        end
        else begin
            clk1 <= !clk1;
            if(clk1 ==1) begin
                state <= next_state;
                y <= enc_out[1];
            end
            else begin
                state <= state;
                y <= enc_out[0];
            end
            case(state)
                s0:if(x==0) begin
                    next_state <= s0;
                    enc_out <= 2'b00;
                end
                else begin
                    next <= s2;
                    enc_out <= 2'b11;
                end
                s1:if(x==0) begin
                    next_state <= s0;
                    enc_out <= 2'b11;
                end
                else begin
                    next_state <= s2;
                    enc_out <=2'b00;
                end
                s2:if(x==0) begin
                    next_state <= s1;
                    enc_out <= 2'b10;
                end
                else begin
                    next_state <= s3;
                    enc_out <= 2'b01;
                end
                s3:if(x==0) begin
                    next_state <= s1;
                    enc_out <= 2'b01;
                end
                else begin
                    next_state <= s3;
                    enc_out <= 2'b10;
                end
                default:if(x==0) begin
                    next_state <= s0;
                    enc_out <= 2'b10;
                end
                else begin
                    next_state <= s2;
                    enc_out <= 2'b01;
                end
            endcase
        end
    end
endmodule
```

